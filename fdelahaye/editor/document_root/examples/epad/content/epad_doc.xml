<?xml version="1.0" encoding="UTF-8"?>
<epad xml:lang="fr-FR"><h>Document déscriptif du projet EPAD</h><ul><li><p>Que veut dire EPAD ? Embeddable Platform Application Documenting.</p></li><li><p>Qu'est-ce que c'est ? une solution intégrable à une platforme d'application et à ses processus pour en gérer la documentation. </p></li><li><p>Comment s'y intègre-t-elle pour gérer quels besoins documentaire ?</p><ul><li><p>Les deux besoins de base adressés en priorité sont :</p><ul><li><p>de pouvoir consulter, des manières les plus efficaces et intègres possibles (navigation/search...), cette documentation afin de savoir : </p><ul><li><p>ce que gèrent comme données et font fonctionnellement les applications de la plateformes et les divers bundles qui composent ces applications =&gt; périmètres fonctionnel (données du membre, infos bancaires, scénarios d'inscription, rgpd etc...); </p></li><li><p>comment les élément de code de ces divers applications et bundles (tables, modèles, controleur, vues, services, crons etc...), implémentent ces périmètres... et inversement : à l'implémentation de quels périmètres, un (ou plusieurs) élément de code donnés participe(nt) et comment. </p></li></ul></li><li><p>de pouvoir maintenir cette efficacité au fil des évolutions de ces applications, avec un coup d'effort de cette maintenance minimisé, via des scénarios de création/révision/mise à jour automatisés de cette documentation. </p></li><li><p>un effet corollaire de cette solution est de pouvoir contribuer concrêtement à être plus "aware" des écart de complexités entre les périmètre fonctionnel et leur implémentation : </p><ul><li><p>Soit en se rendant compte à l'aide de cette doc qu'un périmètre fonctionnel supposé simple est plus complex qu'il n'y parait; </p></li><li><p>Soit en se rendant compte à l'aide de cette doc qu'un périmètre fonctionnel d'une complexité assez "stanard" est implémenté via une solution d'une comlexité "pas standard"; </p></li></ul></li><li><p>... et donc cette solution contribue ainsi à la résolution de ces écart lorsqu'ils sont estimés injustifiés avec des conséquences potentielles sur la stabilité de la plateforme et/ou cout de sa maintenance évolutive. </p></li></ul></li><li><p>Les scénarios de base adressés en priorité sont :</p><ul><li><p>Initialiser automatiquement la documentation de ces périmètres fonctionnel (en lien avec les élément de code qui les implémentent), en capturant les élément de connaissance existant pour chacun d'eux dans les divers outils de gestion : gitlab =&gt; git log -p sur chaque élément de code pour avoir son historique de chgt =&gt; recup des réferences des tkt redmine ds les cmt de commit =&gt; redmine : récup des desc et cmt des tkt =&gt; initilisation des élément de contenus de cette documentation en statut draft avec copies des element de connaissance récupérés; </p></li><li><p>Poste rédacteur :</p><ul><li><p>Paramétrage d'une solution de rédaction des cette doc permettant de convertir efficacement ces version draft avec l'ensemble des ces élément de connaissance, en une première version de la doc de chaque périmètre fonctionnel des apps/bundles précités (données membre, inscription, info bancaire, transfert brancaire, rgpd...); </p></li><li><p>Rédaction des évolutions de feature, et/ou nouvelles features, directement dans cette documentation avec lien vers le tkt redmine; en prio 2 : possibilité de scafolder les nouveaux élément de code requis (nouvelle classe controleur, modèle, view etc...). Scafolder = générer automatiquement le code des squelettes des dites classes. </p></li></ul></li><li><p>Gestion des évolution : paramétrage d'une gestion de révision analysant les merges request et leur liens avec les tkt référencés, afin d'indiquer au rédacteur/vérificateur de la doc de tel ou tel l'apps / bundle, les élément de contenus documentaires à vérifier, en fonction des chgt des élément de code qui sont liés à ces élément de contenus documentaires, et pour lesquels un chgt a été détecté dans la merge request. </p></li><li><p>Post consulteur : paramétrage d'une solution de publication de la documentation rédigée (ou d'une révision de celle-ci), dans un (ou plusieurs) format dédié(s) consultation/recherche, et intégrés dans les divers outils des processus de gestion de la plateforme : en prio un site dédié à la consultation de cette doc, mais si ça s'avère utile elle peut aussi être publiée comme wikis gitlab, doc d'aide en ligne our phpstorm, gros doc pdf permettant la consultation de toute la doc en offline, avec une (ou plusieurs) version(s) papier de qualité etc... pour illustrer le niveau de fonctionnalité de recherche ciblé : on pourra par exemple rechercher tous les formulaires de tel ou tel app/bundle qui permettent la saisie de telle ou telle champ bdd. </p></li><li><p>En prio 2 : possibilité de paramétrer (globalement ou par tkt), des blocages (et ou simple alerte non bloquante), lors des franchissement de step du process dev/review/met/mep, si certaines vérif de mise à jour de la doc induite par le tkt d'évol n'ont pas été faites/vérifiées. </p></li><li><p>En prio 2 : éventuellement envisager de gérer aussi la doc d'infra de la plateforme via epad... </p></li></ul></li></ul></li><li><p>Comment EPAD est-elle implémentée ? voilà un résumé des concept et outils prévus d'être intégrés pour implémenter une première version : </p><ul><li><p>XML/XSD est choisi comme format pour cette documentation : XML/XSD est au domaine des applications de gestion de contenus documentaires, ce que SGBDR/SQL est au domaine des applications de gestion de données : </p><ul><li><p>Les BDD relationelles permettent de définir un schéma SQL "métier" des données créées et lues en bdd, et offrent un langage standard d'accès à ces données (SQL/ORM); </p></li><li><p>Idem pour XML : une documentation XML permet de définir un schéma XSD "métier" des contenus créés et lus dans les document, et offre un langage standard d'accès à ces contenus (XQuery/DOM); </p></li><li><p>A partir de ce langage d'accès SQL, on peut batir des application avancées avec un haut niveau d'automtisation de la gestion des données modélisées; </p></li><li><p>Idem pour XML : à partir de XQuery/DOM, on peut batir des application documentaires avancées avec un haut niveau d'automtisation de la gestion des contenus modélisés; </p></li><li><p>Les application web SQL se basent sur des framework HTML/CSS/JS pour implémenter les scénarios écrans d'interactions utilisateur avancés, flexibles et évolutif; </p></li><li><p>Idem pour XML : Les application d'édition/consultation et gestion de contenus documentaires xml se base aussi sur HTML/CSS/JS pour les même raison; </p></li></ul></li><li><p>... d'autres part j'ai déjà une bonne expérience de telles applis de gestion de contenus xml, donc moins de courbe d'apprentissage... </p></li><li><p>Le principe de base de conception de ce schéma de contenus (donc du/des xsd définissant le jeu de document/contenus géré par epad) : </p><ul><li><p>Préambule/promesse : ce principe est une "tentative de recette gagnante"(*), issue de mes connaissances et expériences sur : les archis XML/XSD de système de documentation techniques dans divers domaines (software, automotive, telecom, avionique...), les standard de modélisation de plateforme d'apps tels que BPMN et UML (éventuellement les diagrammes cisco si on couvre la doc d'infra en prio 2...), le parsing de langages de programation et la création d'AST, Databases, Web framework (sf en base). Pour autant rien des aspect potentiellement complexes et abstrait de ces concept ne fait partie de la partie visible de l'iceberg de cette solution, qui doit offrir une logique d'utilisation certe structurée et scalable, mais toujours dans un vocabulaire et une logique correspondant aux divers rôles des divers acteur utilisant epad (moa, planning, dev, managers). En aucun cas l'un de ces rôles ne doit avoir à comprendre les méandres internes de conception d'epad pour parvenir à faire ce qu'il doit faire avec. <em>(*) attention y a des recettes qui ont bon gout mais qui sont pas si bonne pour toit... ou le contraire ;) : traduction : tu peux avoir une appli qui te plait au quotidien, mais dans les fait t'es moins productif qu'avant avec... ou le contraire. </em> </p></li><li><p>Une feature d'une app répond à un "template fonctionnel" de base : par exemple la saisie des données personelles d'un membre est une feature fonctionnel de type "scénario écran simple" qui se décompose en : </p><ul><li><p>un jeu de données : "les données personnelles du membre", avec d'éventuelles contraintes sur le format des valeur saisies (numérique, date DD/MM/YY ...); </p></li><li><p>le ou les divers uri(s) déclenchant ce scénario, invoqué(s) soit via le champ de saisie d'uri du navigateur, soit via un bouton, lien ou autre widget déclenchant cet uri, avec les diverses données métier de cette uri ( = les paramètres métier contenus dans la request créée avec cette uri). </p></li><li><p>un écran permettant leur saisie, avec d'éventuel widget d'aide à la saisie de certains champ de ce jeu; </p></li><li><p>l'action d'enregistrement des données saisies, qui doit éventuellement appliquer certaines régles de gestion sépcifiques en plus de l'enregistrement proprement dit que jeu de données saisi; </p></li><li><p>optionellement, ces règles de gestion, selon ce qu'elles sont, peuvent être communes à d'autres scénarios écrans, auquel cas elles sont plutôt caractérisées comme un "jeu de régle de gestion", que l'on pourrait référencer dans la déscription d'autres scénarios écrans qui les exécutent également. </p></li><li><p>on pourra indiquer également les id des rôles pouvant exécuter ce scénarios, avec par défaut les rôles de base suivant : "membre" pour un scénario fo comme celui-ci, et "acteur bo" pour unscénario bo et qui regroupe : les acteur moa, les acteur bilendi tech et les acteur bo du client. </p></li></ul></li><li><p>La déscription de cette feature se décompose donc en ces diverses déscriptions, avec optionellement cette réference à un "jeu de régle de gestion" intégré dans d'autres scénarios; </p></li><li><p>Pour autant les données de ce scénario sont des données de la bdd qui sont potentiellement affichées/modifiées par d'autres scénarios écrans, et il est donc aussi préférable de décrire ces données de manière à pouvoir les référencer dans divers scénarios. Il en va de même pour la déscription des rôles. </p></li><li><p>On peut donc maintenant définir un schéma xsd qui définit une telle structuration de contenu, et utiliser un editeur xml,"xsd aware(voir plus loin/plus tard)", qui guidera le rédacteur pour rédiger la déscription de ces contenus via une interface classique d'édition de document, mais cette interface étant "guidée" par ce schéma xsd sous-jacent de "règles de structuration de ces contenus": cf ci-après la description de l'editeur "online web" Xopus. </p></li><li><p>Par ailleurs la bonne nouvelle (mais en fait c'est pas un hasard), est que cette structuration de contenus se mappe très bien avec l'architecture MVC du code qui implémente cette feature : </p><ul><li><p>L'objet ORM Member implémente le jeu de données métier "membre" =&gt; on peut donc lui faire correspondre un contenu xml dans lequel on décrit "niveau métier" ces divers propriétés et contraintes de création/suppression, bref une description niveau métier des contraintes sur cet ORM =&gt; cf annotation @Constraint au niveau de la classe. </p></li></ul></li><li><p>Et en fait, on peut "généraliser", en disant que si on regarde les (principaux) élément de code d'une app/un bundle , ils implémentent tous une partie du comportement métier de la feature : </p><ul><li><p>Un objet orm gère les données d'une table =&gt; on a un élément de contenu qui décrit (niveau métier) les divers propriétés et contraintes de cette table; </p></li><li><p>Un objet controleur gère l'éxécution d'un ou plusieurs scénarios métier tel que décrit ci-avant =&gt; on référence ce controleur au niveau de chacun des contenus xml décrivant ces scénarios métier; </p></li><li><p>Une view twig de type formulaire permet la lecture/modification de d'un jeu de données =&gt; on référence également cette view au niveau de chacun des contenus xml décrivant ces scénarios métier, avec les références du jeu de champ bd géré par ce formulaire; </p></li><li><p>Un service implémente divers régles de gestion, appelées dans divers scénarios métier =&gt; on a un élément de contenu qui décrit les diverses régles de gestion implémentées par ce service et qui est référencé dans la déscription des actions des scénarios métier qui les invoquent; </p></li><li><p>De la même façon, on a un élément de contenu pour chaque cron qui décrit (niveau métier) son comportement, ainsi que pour chaque "query" des objet ORM Repository qui en général effectuent de requêtes complexes sur les données métier répondant à une description métier de ces requetes dans une feature (par exemple une feature "rapport"); </p></li></ul></li><li><p>Et enfin, à partir de ces élément de contenus décrivant chacun soit une feature métier de base comme un scénario simple de saise de donnée personnelles, un cron, une query etc... on peut décrire des features de type "scénario métier multi acteur", qui combinent ces élément de contenus des feature simple , en mode qui/quoi/quand : un exemple : la feature de transfert de credit bancaire mpz combine : </p><ul><li><p>un scénario "membre" d'écran simple de saisi de coodonées bancaire (dans lequel sont décrit les règles de gestion autorisant leur saisie (cf tkt <a href="https://redmine.bilendi.com/issues/54219">#54219</a>, ou réféférencées si ces régle de gestion sont utilisées dans une autre feature et donc codées dans un service plutot que directement le controleur). </p></li><li><p>puis un scénario "membre" d'écran de déclenchement du crédit par le user,</p></li><li><p>et un crons "appli mpz" qui pousse les credit dans le réseau interbancaire.</p></li></ul></li><li><p>On a donc bien une structure de déscription pour un "scénario métier multi acteur", qui est en base une séquence de : Qui exécute Quelle feature à Quel moment. On se basera sur le dialecte BPMN (qui est un dialecte niveau "expert métier" qui inclut aussi des condition de transitions entres actions, des evennement de début, fin, intermédiaires etc...). </p></li><li><p>...et encore enfin...: comme notre plateforme fonctionne bcp sur des features de base dans les bundles, qui sont ensuite personnalisées dans les apps, ben à l'image du code, on décrit la feature personnalisée en référençant la feature de base et en décrivant les différences de comportement que fait la feature personnalisée par rapport à celle de base. </p></li></ul></li><li><p>L'API (REST) Gitlab permet d'accéder aux repos de sources des apps et bundles, ainsi qu'aux merge requests (en json), avec la liste des commit et donc des sources modifiés et les références aux tkt à l'origine des chgt dans ces sources. </p></li><li><p>L'API (REST) Redmine permet d'accéder au tkt, leur description et historique de notes/cmt.</p></li><li><p>L'outils php-parser permet de convertir les repos des sources en une arbo d'AST correspondante au format JSON, avec les classes, les méthode, les statment des méthodes avec les appel d'autres méthodes dans les statment etc ... : </p><ul><li><p>cela permet de générer à partir de cette arbo, le schéma XSD de la documentation en générant : </p><ul><li><p>pour chaque méthode controleur un élément xml contenant sa déscription au format "scénario écran simple" décrit ci-avant, </p></li><li><p>idem pour chaque méthode d'un service son élément xml déscriptif de type "régle de gestion", </p></li><li><p>idem pour chaque view de type formulaire, son élément xml désciptif de type "désciprtion de formulaire", </p></li><li><p>idem pour chaque objet ORM, son élément xml déscriptif de type "déscription de jeu de données", </p></li><li><p>idem pour chaque cron son élément xml de type "déscription de cron",</p></li><li><p>idem pour chaque query son élément xml de type "déscription de requête",</p></li><li><p>etc... on pourra rajouter ainsi, au fil des retour d'expérience, d'autres mapping pour d'autres "élément de code" implémentant un comportement métier, en se basant sur leur "design pattern" pour définir la structure de l'élément xml qui les décrit. </p></li><li><p>on pourra également rajouter diverses "régle de génération", afin de filtrer divers élément pour lesquel on ne veut pas décrire de comportement métier, ou d'autres règles de génération qui étendent ou modifient la génération par défaut de l'élément xml d'un tel élément de code etc... </p></li></ul></li></ul></li><li><p>Le moteur de transformation <a href="http://www.saxonica.com/download/download_page.xml">XSLT 3 Saxon </a> supportant la conversion JSON To XML combiné à php-parser permet de : </p><ul><li><p>générer les fichier xsd et xml à partir des AST en JSON,</p></li><li><p>intégré aux API REST de merge request Gitlab et de tkt Redmine : flagguer les élement xml de la doc potentiellement à réviser selon le code modifié dans une merge request, </p></li><li><p>intégré à l'outil BaseX ou eXist (cf ci-après), permet de générer la doc en un html dédié consultation/navigation/search, et/ou (et pas forcément intégrés aux dit outils), en d'autres format (online help, pdf, mark down, openoffice, ms word etc...), via des outils complémentaires de gestion de ces format (notament les format complexes ou binaire, par exemple fop pour pdf etc...). </p></li><li><p>XSLT 3 (et donc Saxon) supporte la conversion de json dans un format xml équivalent, ce qui permet de stocker les AST en JSON directement dans BaseX ou eXist, et de pouvoir également les requêter afin d'obtenir des possibilité de requêtes avancées combinant les les élément de code et leur contenus, avec les élément xml les décrivant et leur contenus. Par exemple pour retrouver tous les élément de contenus à réviser suite à la modification d'une méthode dans le code, on pourrait exécuter une requete du genre : "trouver tous les élément de code qui appellent cette méthode directement ou indirectement, et tous les contenus les décrivant". </p></li><li><p> <em>NB : Saxon permet d'être intégré dans un script (ou une appli) PHP : il exist une extension php pour Saxon qu'il faut configurer dans php.ini. </em> </p></li></ul></li><li><p>L'intégration d'une bdd xml gratuite comme <a href="http://basex.org/">BaseX</a> ou <a href="http://exist-db.org/exist/apps/homepage/index.html">eXist </a> permet d'implémenter à la fois un site de consultation de cette doc, mais aussi un module cms de gestion des contenus xml édités (cf ci-après). En prio 2 à voir si remplacer cette brique par le tandem Symfony/Postgesql est jouable =&gt; il faut alors développer un mapping des contenus xml dans un schéma de donnée postgres adhoc, avec le même niveau de requetage que XQuery le permet dans BaseX/eXist =&gt; c 'est pas pour demain...NB : il est possible de développer ce module cms avec le framework symfonu via "un client php" pour BaseX, ou une API REST pour eXist =&gt; à voir si déperdition fonctionnel problématique par rapport à un développement avec le langage natif de ces deux sgbd qui est java... </p></li><li><p>Une personnalisation de l'editeur "online web" <a href="https://docs.sdl.com/LiveContent/content/en-US/SDL%20Xopus%20references-v5/GUID-05A324E6-F7DF-4826-BCC0-4EA892BECCC2#addHistory=true&amp;filename=GUID-24EA4417-88AD-460D-814F-C0AD6DF4BFF2.xml&amp;docid=GUID-8240D97A-6F7A-46A3-98FE-8F3A6825BD96&amp;inner_id=&amp;tid=&amp;query=&amp;scope=&amp;resource=&amp;toc=false&amp;eventType=lcContent.loadDocGUID-8240D97A-6F7A-46A3-98FE-8F3A6825BD96"> XML Xopus </a> (via des script xslt-&gt;html/js/css), permet d'implémenter le poste rédacteur décrit ci-avant (même avec une version "unlicensed"...), intégré au dit module cms. <em>NB : Xopus est un module pur js et n'est donc pas lié au langage d'implémentation du cms sous-jacent : il s'intègre donc à celui-ci, qu'il soit en java ou php ou autre. </em> </p></li><li><p>NB : il parait quand même intéressant (et à priori possible), de pouvoir intégrer l'ensemble des scénarios cibles décrit ci-avant, et des outils qui les implémentent (API REST GitLab/Redmine,Saxon, php-parser, BaseX/eXist,Xopus), en un BO "EPAD", avec un dashboard permettant le déclenchement des divers fonctionnalités par les divers acteur (génération auto des contenus documentaire d'un repo par un dev et/ou d'une révision des contenus induit par une merge request, et/ou rédaction from scratch d'un nouveau scénarios par un dev ou un non dev, et/ou listage/consultation des contenus à vérifier d'une merge request et lancement de l'éditeur sur ceux à modifier, et/ou consultation/recherche dans la release courante de la doc par tout le monde etc...). Le framework sf est un bon candidat pour implémenter une telle intégration d'outil en un BO dédié. La stack rust/wasm avec le framework Yew a p'tet l'avenir (à voir si cette solus technique est déjà fonctionnelle). </p></li></ul></li><li><p>Un besoin qui pourrait être adressé dans un second temps est d'intégrer, mais on préfèrera le terme "combiner", Epad et Redmine afin de :</p><ul><li><p>Pouvoir paramétrer des templates de rédaction de contenu à des type de tkt Redmine;</p></li><li><p>On préfèrera le terme "modèle de contenu" plutôt que "template", car l'idée est de proposer :</p><ul><li><p>quelquechose de bien plus flexible que des templates classiques de doc, autorisant bcp plus de variantes possibles des élément de contenu saisis, et basé sur la structure du contenu (pour un type de tkt/tracker donné);</p></li><li><p>permettant de paramétrer plusieurs layout possibles de rendu de ce contenu;</p></li><li><p>et permettant aussi d'automatiser la création d'élément de contenu (en générant tout ou partie de ceux-ci de manière automatique), voir même leur actualisation/mise à jour ;</p></li><li><p>comme par exemple, aller rechercher dans la base de contenus, à partir du type de tracker et des champs saisis dans le tkt (projet : app/bundle, programme(s) cible(s)...) :</p><ul><li><p>divers contenus de référence en support/prérequis de la compréhension de la déscription de la demande et mettre un lien vers ceux-ci dans la déscription: par exemple sur un tkt d'évol du trac bundle, référencer automatiquement la doc décrivant ce que fait le bundle, celle décrivant les principes de conception de base de ce bundle et les guideline d'implémentation spécifique à ce bundle;</p></li></ul></li><li><p>on pourrait aussi rajouter un champ "feature" dans le tracker, indiquant que le tkt est un tkt d'évolution de la dite feature, et alors retrouver dans la base de contenu celui décrivant cette feature là et le référencer dans le tkt;</p></li><li><p>bref, on pourra imaginer, à partir d'une base gérée des contenus de connaissance de la plateforme, tous les scénarios automatisables de rédaction des contenus de déscription des tkt permettant une rédaction assistée beaucoup plus rapide, complète et intègre de ces déscription;</p></li><li><p>exemple encore plus concrêt :</p><ul><li><p>je dois faire un tkt d'évolution des règles de gestion de la feature "Personal Info" d'un compte mxm :</p></li><li><p>je saisis dans le tkt du prj redmine mxm les champs : feature = "Personal Info", part = "régle de gestion";</p></li><li><p>ça ouvre un éditeur sur le contenus déscriptif des régles de gestion de cette feature retrouvé dans la base de contenus à partir de ces champs;</p></li><li><p>je fais les modif objet de l'évol via cet editeur;</p></li><li><p>je valide et ça affiche la description de la demande un diff visuel de ces changement de régles de gestion, avec le lien vers la doc fonctionnelle complète de la feature, les liens vers les élément de codes l'implémentant pour pouvoir les browser etc...</p></li></ul></li></ul></li></ul></li><li><p>Random thought : en rédigeant les besoins/solus ci-avant, est-ce que finalement une "meilleure façon de marcher" ne serait pas de considérer que la base d'un meilleur fonctionnement pour la gestion d'une plateforme serait de baser les process de gestion de celle-ci sur un tel référentiel de contenus de connaissance plutôt que sur redmine =&gt; à méditer dans un 3eme temps mais l'idée serait de gérer ce reférentiel de contenu ET les contenus des description (et cmt) des tkt dans un même référentiel, et baser les process de gestion de tkt sur un tel référentiel commun; à voir aussi la même reflexion vis à vis des contenus gitlab =&gt; en gros quid de gérer tous les contenus des processus de gestion de la plateforme dans un même référentiel de contenus et baser l'ensemble des processus de gestion de la plateforme (amont : demandes d'évol, correctif, nouveau prj etc... et aval : gestion de la réalisation technique de ces demandes : merge request etc...) sur ce réferentiel commun (qui n'inclut pas git biensûr : que les contenus de gestion) ? =&gt; en gros une solus full intégrée et "contenu centrique" de ces processus de gestion de plateforme : à méditer en temps 3...</p></li><li><p>Random thought : en y repensant, cette aproche de solution là me parait top : </p><ul><li><p>On permet la définition de schémas de structure de contenu arbitraires (=&gt; les "DAS" = Document Architecture Schemas) : afin qu'un groupe de personne puissent contribuer à ces définition =&gt; le "DAG" := Documentation Architecture Group : en base, toutes les personnes ayant à utiliser (directement) tout ou partie de cette doc font par défaut partie du DAG (ensuite à voir divers rôles éventuellement ds ce groupe), et peut donc ainsi contribuer de ces idées/proposition sur cette architecture;</p></li><li><p>On définit un process associé : le "DAP" = Documentation Architecture Process : en base, chaque membre du DAG a un "espace privé", dans lequel il peut sketcher des évolutions de ces schémas de structure : un principe de scafolding permet de générer un doc "exemple" d'un schéma que le membre peut ensuite modifier pour pouvoir faire des démos aux autres membre de ces idées d'évol, illustrere les nouveaux élément de contenus qu'il propose etc...</p></li><li><p>la définition de schémas de structure par un membre se fera via l'édition de ce schéma comme un document : un paramétrage d'édition d'un schéma xsd via xopus permettra ça : ce sera donc une version réduite de schéma xsd adapté à la définition de schéma de structure de document contextualisé à l'organisation , en supprimant toutes les élément/attributs/mécanisme xsd qui ne font pas de sens dans le contexte de cette organisation etc...</p></li></ul></li><li><p>Court terme : ce qui parait être contributif dans le court terme chez Bilendi est un éditeur basé sur le template de déscription de note de dev actuelle (les retour sont que c'est plus clair que les autres contenu de tkt ne l'utilisant pas), mais incluant aussi des élément pour structurere (et automtiser) l'édition de la partie demande (donc rédigé par les team moa et/ou moe);</p><ul><li><p>cet éditeur serait couplé à un parser textile qui convertirait à la volé le textile dans le schéma d'édition correspondant à ce template, afin de récupérer le contenu d'une description redmine (soit conforme à ce template soit non), et permettre une édition automatisée conforme à ce schéma;</p></li><li><p>il proposerait aussi un générateur textile afin que la version de description redmine mise à jour via cette éditeur puisse être aussi mise à jour ds le tkt;</p></li><li><p>il proposerait le même principe avec le format markdown de gitlab, et on pourrait ainsi convertir les contenus des descr des tkt en wiki de description de feature dans gitlab, et/ou editer un wiki gitlab dans l'éditeur et en republier la version maj dans gitlab;</p></li><li><p>et la solus docusaurus permet de servir un site simple de consultation de ces wiki gitlab (et on doit je crois pouvoir enrichir docusaurus avec des feature de consultation de la doc plus avancées);</p></li><li><p>dernière idée : (au moins ds un 1er temps pour fournir une 1ere contrib plus vite) : plutôt que coder/inégrer des parser textile/markdown vers le format xml de l'éditeur, on pourrait simplement mettre un WARNING en haut de la Description redmine / le wiki markdown : <strong>"DON'T EDIT ME BUT EDIT <a href="http://en.wikipedia.org/wiki/Charlemagne">ME</a> (AND THEN UPDATE ME).</strong></p></li><li><p>le lien ME pointerait vers le lancement de l'edition du contenu de description redmine / wiki markdown correspondant, et des btn "export for redmine" / "export for gitlab" permetterait de générer le contenu de l'éditeur au format textile/markdown pour faire facilement la mise à jour du contenu de description redmien du tkt / du wiki gitlab.</p></li><li><p>on se fixe un 1er sketch de démo de cette dernière idée asap, et en + on pourrait test beder la pertinence (ou pas) de cette pratique entre un sample de tkt/wiki gitlab de feature gérés avec cette pratique vs les autre gérés avec la pratique actuelle.</p></li></ul></li></ul><dataset_definition behavior="section" view="normal"><h/><p/><data_definition behavior="section" view="normal"><h/><property_definition behavior="section" view="normal"><h/><p/></property_definition></data_definition></dataset_definition></epad>
