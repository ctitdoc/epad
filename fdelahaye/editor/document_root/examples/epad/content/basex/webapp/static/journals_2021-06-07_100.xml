<journals>
<issue_68740>
<issue_url>https://redmine.bilendi.com/issues/68740</issue_url>
</issue_68740>
<issue_68739>
<issue_url>https://redmine.bilendi.com/issues/68739</issue_url>
</issue_68739>
<issue_68738>
<issue_url>https://redmine.bilendi.com/issues/68738</issue_url>
</issue_68738>
<issue_68737>
<issue_url>https://redmine.bilendi.com/issues/68737</issue_url>
</issue_68737>
<issue_68736>
<issue_url>https://redmine.bilendi.com/issues/68736</issue_url>
</issue_68736>
<issue_68735>
<issue_url>https://redmine.bilendi.com/issues/68735</issue_url>
</issue_68735>
<issue_68734>
<issue_url>https://redmine.bilendi.com/issues/68734</issue_url>
</issue_68734>
<issue_68733>
<issue_url>https://redmine.bilendi.com/issues/68733</issue_url>
</issue_68733>
<issue_68732>
<issue_url>https://redmine.bilendi.com/issues/68732</issue_url>
</issue_68732>
<issue_68731>
<issue_url>https://redmine.bilendi.com/issues/68731</issue_url>
</issue_68731>
<issue_68724>
<issue_url>https://redmine.bilendi.com/issues/68724</issue_url>
</issue_68724>
<issue_68722>
<issue_url>https://redmine.bilendi.com/issues/68722</issue_url>
</issue_68722>
<issue_68721>
<issue_url>https://redmine.bilendi.com/issues/68721</issue_url>
</issue_68721>
<issue_68720>
<issue_url>https://redmine.bilendi.com/issues/68720</issue_url>
</issue_68720>
<issue_68716>
<issue_url>https://redmine.bilendi.com/issues/68716</issue_url>
</issue_68716>
<issue_68715>
<issue_url>https://redmine.bilendi.com/issues/68715</issue_url>
</issue_68715>
<issue_68714>
<issue_url>https://redmine.bilendi.com/issues/68714</issue_url>
</issue_68714>
<issue_68698>
<issue_url>https://redmine.bilendi.com/issues/68698</issue_url>
</issue_68698>
<issue_68697>
<issue_url>https://redmine.bilendi.com/issues/68697</issue_url>
</issue_68697>
<issue_68689>
<issue_url>https://redmine.bilendi.com/issues/68689</issue_url>
</issue_68689>
<issue_68687>
<issue_url>https://redmine.bilendi.com/issues/68687</issue_url>
</issue_68687>
<issue_68683>
<issue_url>https://redmine.bilendi.com/issues/68683</issue_url>
</issue_68683>
<issue_68682>
<issue_url>https://redmine.bilendi.com/issues/68682</issue_url>
</issue_68682>
<issue_68681>
<issue_url>https://redmine.bilendi.com/issues/68681</issue_url>
</issue_68681>
<issue_68679>
<issue_url>https://redmine.bilendi.com/issues/68679</issue_url>
</issue_68679>
<issue_68676>
<issue_url>https://redmine.bilendi.com/issues/68676</issue_url>
</issue_68676>
<issue_68675>
<issue_url>https://redmine.bilendi.com/issues/68675</issue_url>
</issue_68675>
<issue_68674>
<issue_url>https://redmine.bilendi.com/issues/68674</issue_url>
</issue_68674>
<issue_68673>
<issue_url>https://redmine.bilendi.com/issues/68673</issue_url>
</issue_68673>
<issue_68672>
<issue_url>https://redmine.bilendi.com/issues/68672</issue_url>
</issue_68672>
<issue_68671>
<issue_url>https://redmine.bilendi.com/issues/68671</issue_url>
</issue_68671>
<issue_68669>
<issue_url>https://redmine.bilendi.com/issues/68669</issue_url>
</issue_68669>
<issue_68668>
<issue_url>https://redmine.bilendi.com/issues/68668</issue_url>
</issue_68668>
<issue_68665>
<issue_url>https://redmine.bilendi.com/issues/68665</issue_url>
</issue_68665>
<issue_68664>
<issue_url>https://redmine.bilendi.com/issues/68664</issue_url>
</issue_68664>
<issue_68663>
<issue_url>https://redmine.bilendi.com/issues/68663</issue_url>
</issue_68663>
<issue_68660>
<issue_url>https://redmine.bilendi.com/issues/68660</issue_url>
</issue_68660>
<issue_68658>
<issue_url>https://redmine.bilendi.com/issues/68658</issue_url>
</issue_68658>
<issue_68657>
<issue_url>https://redmine.bilendi.com/issues/68657</issue_url>
</issue_68657>
<issue_68656>
<issue_url>https://redmine.bilendi.com/issues/68656</issue_url>
</issue_68656>
<issue_68655>
<issue_url>https://redmine.bilendi.com/issues/68655</issue_url>
</issue_68655>
<issue_68653>
<issue_url>https://redmine.bilendi.com/issues/68653</issue_url>
</issue_68653>
<issue_68651>
<issue_url>https://redmine.bilendi.com/issues/68651</issue_url>
</issue_68651>
<issue_68650>
<issue_url>https://redmine.bilendi.com/issues/68650</issue_url>
</issue_68650>
<issue_68649>
<issue_url>https://redmine.bilendi.com/issues/68649</issue_url>
</issue_68649>
<issue_68647>
<issue_url>https://redmine.bilendi.com/issues/68647</issue_url>
</issue_68647>
<issue_68646>
<issue_url>https://redmine.bilendi.com/issues/68646</issue_url>
</issue_68646>
<issue_68645>
<issue_url>https://redmine.bilendi.com/issues/68645</issue_url>
</issue_68645>
<issue_68644>
<issue_url>https://redmine.bilendi.com/issues/68644</issue_url>
</issue_68644>
<issue_68643>
<issue_url>https://redmine.bilendi.com/issues/68643</issue_url>
</issue_68643>
<issue_68642>
<issue_url>https://redmine.bilendi.com/issues/68642</issue_url>
</issue_68642>
<issue_68641>
<issue_url>https://redmine.bilendi.com/issues/68641</issue_url>
</issue_68641>
<issue_68640>
<issue_url>https://redmine.bilendi.com/issues/68640</issue_url>
</issue_68640>
<issue_68639>
<issue_url>https://redmine.bilendi.com/issues/68639</issue_url>
</issue_68639>
<issue_68637>
<issue_url>https://redmine.bilendi.com/issues/68637</issue_url>
</issue_68637>
<issue_68636>
<issue_url>https://redmine.bilendi.com/issues/68636</issue_url>
</issue_68636>
<issue_68635>
<issue_url>https://redmine.bilendi.com/issues/68635</issue_url>
</issue_68635>
<issue_68632>
<issue_url>https://redmine.bilendi.com/issues/68632</issue_url>
</issue_68632>
<issue_68631>
<issue_url>https://redmine.bilendi.com/issues/68631</issue_url>
</issue_68631>
<issue_68630>
<issue_url>https://redmine.bilendi.com/issues/68630</issue_url>
</issue_68630>
<issue_68629>
<issue_url>https://redmine.bilendi.com/issues/68629</issue_url>
</issue_68629>
<issue_68628>
<issue_url>https://redmine.bilendi.com/issues/68628</issue_url>
</issue_68628>
<issue_68627>
<issue_url>https://redmine.bilendi.com/issues/68627</issue_url>
</issue_68627>
<issue_68626>
<issue_url>https://redmine.bilendi.com/issues/68626</issue_url>
</issue_68626>
<issue_68620>
<issue_url>https://redmine.bilendi.com/issues/68620</issue_url>
</issue_68620>
<issue_68617>
<issue_url>https://redmine.bilendi.com/issues/68617</issue_url>
</issue_68617>
<issue_68616>
<issue_url>https://redmine.bilendi.com/issues/68616</issue_url>
<journal id="638285">
  <user id="529" name="Franck D."/>
  <notes/>
  <created_on>2021-06-07T12:03:25Z</created_on>
  <private_notes>false</private_notes>
  <details type="array">
    <detail property="attr" name="assigned_to_id">
      <old_value/>
      <new_value>723</new_value>
    </detail>
  </details>
</journal>
<journal id="638286">
  <user id="529" name="Franck D."/>
  <notes/>
  <created_on>2021-06-07T12:03:43Z</created_on>
  <private_notes>false</private_notes>
  <details type="array">
    <detail property="attr" name="description">
      <old_value>{{ToC}}

h1.Requester request

_NB: technical level contents are annotated in italic notes delimited by &lt; and &gt;._
See note #67084#note-30 about such a case.
Goal of this tkt is to dev and deploy the solution described in section "Conclusion / décision" of this note.
In a word, here is the business rule to add to the email validator via this ticket :
* when the email is detected as invalid,
* if it is the email of an existing member, _&lt;= validated object retrieved from the validator context is (or inherits from) IdentityBase and its "actif" property is "O" or "J"&gt;_
* then the message sent back to the user/member is specifc to this context : it tells the user to the contact the customer support if he/she is sure his/her email is valid, otherwise change it for a valid one via the "My Account" page.

This business rule is to be applied only if option customize_validation_message_from_context is set. _&lt;= boolean option set to true&gt;_
Such an option can be set either :
* globally, _&lt;= a new customize_validation_message_from_context boolean parameter of the EmailValidator service set to true in services.yml&gt;_
* or on a case-by-case basis, _&lt;= a new customize_validation_message_from_context boolean option of Bilendi's Email constraint class&gt;_
* and the later always takes precedence over the former.

To illustrate such a new business rule : 
* in a cases like #66957 (tommasina.spampinato@virgilio.it) =&gt; it helps providing a quick fix once support has confirmed this email validity;
* and in cases like #68434 (farahnaouii@gmail:com) =&gt; it better guides the user on the proper page to fix such a mistake.

Furthermore, in order to monitor the occurence frequency of such a case, a message (with the invalid email value) is logged when such a case occurs (so only when the email is invalid AND ONLY if it is the email of an EXISTING member, as invalid member emails in registration scenarios are not in the targets scenarios to be taken into account, neither validation of email partners etc...).

@dev : see further technical design level requests in "Technical analysis / design" section.



----

h1. Dev notes

This section has been created with "this template":https://wiki.bilendi.net/doku.php/referentiel_de_pratiques:template_de_contenu#template_de_notes_de_dev

h2. Business analysis / solution

{{collapse()


}}

h2. Technical analysis / design

{{collapse()

To complete the technical requirements written in the request, see the technical level requirements described in note #67084#note-30 / section "Conclusion / décision", for this solution :
* make a dedicated service to implement such a contextual message business rule,
...

The monitoring log action described in the request should not be implemented in such a service, whose purpose in to only implement the "message deduction business rule"; it should rather be implemented in the validator itself, so this leads to dividing the implementation of this new service in 4 new distinct actions/behaviors :
* if "email validation fails"
** _[new behavior]_  if customize_validation_message_from_context is true then :
*** _[new behavior]_ get the "failed validation context case" from context =&gt; this behavior resolves the "invalid case" from the validator context (namely the "object" of the context);
*** _[new behavior]_ add an "INFO log of the occurence of such case with the invalid email and the member id;
*** _[new behavior]_ get the violation message to be returned for this case;
** add the violation message in the context.

The "if customize_validation_message_from_context is true" is implemenyted by first checking if this email constraint is defiend in the incoming Email constraint object (= parameter of EmailValidator.validate() method);
if not then it checks the (new) customize_validation_message_from_context parameter of the EmailValidator service =&gt; this parameter is set to true in the member-bundles services.yml configuration of the EmailValidator service;
then one may define a class EmailValidatorContext  aside EmailValidator dedicated to resolving the validation case;
one may implement the "case" semantic  by an api of it like isExistingMemberCase() =&gt; so this class will just check that an "object" is in context and it is an object of "a member class" =&gt;  and return true only in this case;
as the current violation message implementation requires a refactoring for a long time, one may implement a dedicated class EmailValidatorMessage with an api setExistingMemberCaseMessage($constraintViolations) to implement this new case and another setDefaultCaseMessage($constraintViolations) to refactor the default case (set the default Sf invalid email message);
one also makes a getExistingMemberCaseLogMessage() returning a message consistant and unified with setExistingMemberCaseMessage, to be looged as an "INFO" log;
finally to ensure a loose coupling of the actual EmailValidator behavior and the customize_validation_message_from_context option, one can create a EmailValidatorContextRule service that implements the logic above when customize_validation_message_from_context is true, so that just the existing (refactored) execution of the EmailValidator is executed when this option is disabled (so = false).


}}

h2. Business test scenarios

{{collapse()


}}

h2. Dev phase test report

{{collapse()


}}

h2. Validation phase test report

{{collapse()


}}

h2. Technical tests scenarios

{{collapse()


}}


h2. Technical test report

{{collapse()


}}


----</old_value>
      <new_value>{{ToC}}

h1. Requester request

_NB: technical level contents are annotated in italic notes delimited by &lt; and &gt;._
See note #67084#note-30 about such a case.
Goal of this tkt is to dev and deploy the solution described in section "Conclusion / décision" of this note.
In a word, here is the business rule to add to the email validator via this ticket :
* when the email is detected as invalid,
* if it is the email of an existing member, _&lt;= validated object retrieved from the validator context is (or inherits from) IdentityBase and its "actif" property is "O" or "J"&gt;_
* then the message sent back to the user/member is specifc to this context : it tells the user to the contact the customer support if he/she is sure his/her email is valid, otherwise change it for a valid one via the "My Account" page.

This business rule is to be applied only if option customize_validation_message_from_context is set. _&lt;= boolean option set to true&gt;_
Such an option can be set either :
* globally, _&lt;= a new customize_validation_message_from_context boolean parameter of the EmailValidator service set to true in services.yml&gt;_
* or on a case-by-case basis, _&lt;= a new customize_validation_message_from_context boolean option of Bilendi's Email constraint class&gt;_
* and the later always takes precedence over the former.

To illustrate such a new business rule : 
* in a cases like #66957 (tommasina.spampinato@virgilio.it) =&gt; it helps providing a quick fix once support has confirmed this email validity;
* and in cases like #68434 (farahnaouii@gmail:com) =&gt; it better guides the user on the proper page to fix such a mistake.

Furthermore, in order to monitor the occurence frequency of such a case, a message (with the invalid email value) is logged when such a case occurs (so only when the email is invalid AND ONLY if it is the email of an EXISTING member, as invalid member emails in registration scenarios are not in the targets scenarios to be taken into account, neither validation of email partners etc...).

@dev : see further technical design level requests in "Technical analysis / design" section.



----

h1. Dev notes

This section has been created with "this template":https://wiki.bilendi.net/doku.php/referentiel_de_pratiques:template_de_contenu#template_de_notes_de_dev

h2. Business analysis / solution

{{collapse()


}}

h2. Technical analysis / design

{{collapse()

To complete the technical requirements written in the request, see the technical level requirements described in note #67084#note-30 / section "Conclusion / décision", for this solution :
* make a dedicated service to implement such a contextual message business rule,
...

The monitoring log action described in the request should not be implemented in such a service, whose purpose in to only implement the "message deduction business rule"; it should rather be implemented in the validator itself, so this leads to dividing the implementation of this new service in 4 new distinct actions/behaviors :
* if "email validation fails"
** _[new behavior]_  if customize_validation_message_from_context is true then :
*** _[new behavior]_ get the "failed validation context case" from context =&gt; this behavior resolves the "invalid case" from the validator context (namely the "object" of the context);
*** _[new behavior]_ add an "INFO log of the occurence of such case with the invalid email and the member id;
*** _[new behavior]_ get the violation message to be returned for this case;
** add the violation message in the context.

The "if customize_validation_message_from_context is true" is implemenyted by first checking if this email constraint is defiend in the incoming Email constraint object (= parameter of EmailValidator.validate() method);
if not then it checks the (new) customize_validation_message_from_context parameter of the EmailValidator service =&gt; this parameter is set to true in the member-bundles services.yml configuration of the EmailValidator service;
then one may define a class EmailValidatorContext  aside EmailValidator dedicated to resolving the validation case;
one may implement the "case" semantic  by an api of it like isExistingMemberCase() =&gt; so this class will just check that an "object" is in context and it is an object of "a member class" =&gt;  and return true only in this case;
as the current violation message implementation requires a refactoring for a long time, one may implement a dedicated class EmailValidatorMessage with an api setExistingMemberCaseMessage($constraintViolations) to implement this new case and another setDefaultCaseMessage($constraintViolations) to refactor the default case (set the default Sf invalid email message);
one also makes a getExistingMemberCaseLogMessage() returning a message consistant and unified with setExistingMemberCaseMessage, to be looged as an "INFO" log;
finally to ensure a loose coupling of the actual EmailValidator behavior and the customize_validation_message_from_context option, one can create a EmailValidatorContextRule service that implements the logic above when customize_validation_message_from_context is true, so that just the existing (refactored) execution of the EmailValidator is executed when this option is disabled (so = false).


}}

h2. Business test scenarios

{{collapse()


}}

h2. Dev phase test report

{{collapse()


}}

h2. Validation phase test report

{{collapse()


}}

h2. Technical tests scenarios

{{collapse()


}}


h2. Technical test report

{{collapse()


}}


----</new_value>
    </detail>
  </details>
</journal>
<journal id="638288">
  <user id="529" name="Franck D."/>
  <notes/>
  <created_on>2021-06-07T12:05:57Z</created_on>
  <private_notes>false</private_notes>
  <details type="array">
    <detail property="relation" name="relates">
      <old_value/>
      <new_value>67084</new_value>
    </detail>
  </details>
</journal>
<journal id="638606">
  <user id="529" name="Franck D."/>
  <notes/>
  <created_on>2021-06-08T15:11:57Z</created_on>
  <private_notes>false</private_notes>
  <details type="array">
    <detail property="attr" name="description">
      <old_value>{{ToC}}

h1. Requester request

_NB: technical level contents are annotated in italic notes delimited by &lt; and &gt;._
See note #67084#note-30 about such a case.
Goal of this tkt is to dev and deploy the solution described in section "Conclusion / décision" of this note.
In a word, here is the business rule to add to the email validator via this ticket :
* when the email is detected as invalid,
* if it is the email of an existing member, _&lt;= validated object retrieved from the validator context is (or inherits from) IdentityBase and its "actif" property is "O" or "J"&gt;_
* then the message sent back to the user/member is specifc to this context : it tells the user to the contact the customer support if he/she is sure his/her email is valid, otherwise change it for a valid one via the "My Account" page.

This business rule is to be applied only if option customize_validation_message_from_context is set. _&lt;= boolean option set to true&gt;_
Such an option can be set either :
* globally, _&lt;= a new customize_validation_message_from_context boolean parameter of the EmailValidator service set to true in services.yml&gt;_
* or on a case-by-case basis, _&lt;= a new customize_validation_message_from_context boolean option of Bilendi's Email constraint class&gt;_
* and the later always takes precedence over the former.

To illustrate such a new business rule : 
* in a cases like #66957 (tommasina.spampinato@virgilio.it) =&gt; it helps providing a quick fix once support has confirmed this email validity;
* and in cases like #68434 (farahnaouii@gmail:com) =&gt; it better guides the user on the proper page to fix such a mistake.

Furthermore, in order to monitor the occurence frequency of such a case, a message (with the invalid email value) is logged when such a case occurs (so only when the email is invalid AND ONLY if it is the email of an EXISTING member, as invalid member emails in registration scenarios are not in the targets scenarios to be taken into account, neither validation of email partners etc...).

@dev : see further technical design level requests in "Technical analysis / design" section.



----

h1. Dev notes

This section has been created with "this template":https://wiki.bilendi.net/doku.php/referentiel_de_pratiques:template_de_contenu#template_de_notes_de_dev

h2. Business analysis / solution

{{collapse()


}}

h2. Technical analysis / design

{{collapse()

To complete the technical requirements written in the request, see the technical level requirements described in note #67084#note-30 / section "Conclusion / décision", for this solution :
* make a dedicated service to implement such a contextual message business rule,
...

The monitoring log action described in the request should not be implemented in such a service, whose purpose in to only implement the "message deduction business rule"; it should rather be implemented in the validator itself, so this leads to dividing the implementation of this new service in 4 new distinct actions/behaviors :
* if "email validation fails"
** _[new behavior]_  if customize_validation_message_from_context is true then :
*** _[new behavior]_ get the "failed validation context case" from context =&gt; this behavior resolves the "invalid case" from the validator context (namely the "object" of the context);
*** _[new behavior]_ add an "INFO log of the occurence of such case with the invalid email and the member id;
*** _[new behavior]_ get the violation message to be returned for this case;
** add the violation message in the context.

The "if customize_validation_message_from_context is true" is implemenyted by first checking if this email constraint is defiend in the incoming Email constraint object (= parameter of EmailValidator.validate() method);
if not then it checks the (new) customize_validation_message_from_context parameter of the EmailValidator service =&gt; this parameter is set to true in the member-bundles services.yml configuration of the EmailValidator service;
then one may define a class EmailValidatorContext  aside EmailValidator dedicated to resolving the validation case;
one may implement the "case" semantic  by an api of it like isExistingMemberCase() =&gt; so this class will just check that an "object" is in context and it is an object of "a member class" =&gt;  and return true only in this case;
as the current violation message implementation requires a refactoring for a long time, one may implement a dedicated class EmailValidatorMessage with an api setExistingMemberCaseMessage($constraintViolations) to implement this new case and another setDefaultCaseMessage($constraintViolations) to refactor the default case (set the default Sf invalid email message);
one also makes a getExistingMemberCaseLogMessage() returning a message consistant and unified with setExistingMemberCaseMessage, to be looged as an "INFO" log;
finally to ensure a loose coupling of the actual EmailValidator behavior and the customize_validation_message_from_context option, one can create a EmailValidatorContextRule service that implements the logic above when customize_validation_message_from_context is true, so that just the existing (refactored) execution of the EmailValidator is executed when this option is disabled (so = false).


}}

h2. Business test scenarios

{{collapse()


}}

h2. Dev phase test report

{{collapse()


}}

h2. Validation phase test report

{{collapse()


}}

h2. Technical tests scenarios

{{collapse()


}}


h2. Technical test report

{{collapse()


}}


----</old_value>
      <new_value>{{ToC}}

h1. Requester request

_NB: technical level contents are annotated in italic notes delimited by &lt; and &gt;._
See note #67084#note-30 about such a case.
Goal of this tkt is to dev and deploy the solution described in section "Conclusion / décision" of this note.
In a word, here is the business rule to add to the email validator via this ticket :
* when the email is detected as invalid,
* if it is the email of an existing member, _&lt;= validated object retrieved from the validator context is (or inherits from) IdentityBase and its "actif" property is "O" or "J"&gt;_
* then the message sent back to the user/member is specifc to this context : it tells the user to the contact the customer support if he/she is sure his/her email is valid, otherwise change it for a valid one via the "My Account" page.

This business rule is to be applied only if option customize_validation_message_from_context is set. _&lt;= boolean option set to true&gt;_
Such an option can be set either :
* globally, _&lt;= a new customize_validation_message_from_context boolean parameter of the EmailValidator service set to true in services.yml&gt;_
* or on a case-by-case basis, _&lt;= a new customize_validation_message_from_context boolean option of Bilendi's Email constraint class&gt;_
* and the later always takes precedence over the former.

To illustrate such a new business rule : 
* in a cases like #66957 (tommasina.spampinato@virgilio.it) =&gt; it helps providing a quick fix once support has confirmed this email validity;
* and in cases like #68434 (farahnaouii@gmail:com) =&gt; it better guides the user on the proper page to fix such a mistake.

Furthermore, in order to monitor the occurence frequency of such a case, a message (with the invalid email value) is logged when such a case occurs (so only when the email is invalid AND ONLY if it is the email of an EXISTING member, as invalid member emails in registration scenarios are not in the targets scenarios to be taken into account, neither validation of email partners etc...).

@dev : see further technical design level requests in "Technical analysis / design" section.



----

h1. Dev notes

This section has been created with "this template":https://wiki.bilendi.net/doku.php/referentiel_de_pratiques:template_de_contenu#template_de_notes_de_dev

h2. Business analysis / solution

{{collapse()


}}

h2. Technical analysis / design

{{collapse()

STATUS : DRAFT

To complete the technical requirements written in the request, see the technical level requirements described in note #67084#note-30 / section "Conclusion / décision", for this solution :
* make a dedicated service to implement such a contextual message business rule,
...

The monitoring log action described in the request should not be implemented in such a service, whose purpose in to only implement the "message deduction business rule"; it should rather be implemented in the validator itself, so this leads to dividing the implementation of this new service in 4 new distinct actions/behaviors :
* if "email validation fails"
** _[new behavior]_  if customize_validation_message_from_context is true then :
*** _[new behavior]_ get the "failed validation context case" from context =&gt; this behavior resolves the "invalid case" from the validator context (namely the "object" of the context);
*** _[new behavior]_ add an "INFO log of the occurence of such case with the invalid email and the member id;
*** _[new behavior]_ get the violation message to be returned for this case;
** add the violation message in the context.

The "if customize_validation_message_from_context is true" is implemenyted by first checking if this email constraint is defiend in the incoming Email constraint object (= parameter of EmailValidator.validate() method);
if not then it checks the (new) customize_validation_message_from_context parameter of the EmailValidator service =&gt; this parameter is set to true in the member-bundles services.yml configuration of the EmailValidator service;
then one may define a class EmailValidatorContext  aside EmailValidator dedicated to resolving the validation case;
one may implement the "case" semantic  by an api of it like isExistingMemberCase() =&gt; so this class will just check that an "object" is in context and it is an object of "a member class" =&gt;  and return true only in this case;
as the current violation message implementation requires a refactoring for a long time, one may implement a dedicated class EmailValidatorMessage with an api setExistingMemberCaseMessage($constraintViolations) to implement this new case and another setDefaultCaseMessage($constraintViolations) to refactor the default case (set the default Sf invalid email message);
one also makes a getExistingMemberCaseLogMessage() returning a message consistant and unified with setExistingMemberCaseMessage, to be looged as an "INFO" log;
finally to ensure a loose coupling of the actual EmailValidator behavior and the customize_validation_message_from_context option, one can create a EmailValidatorContextRule service that implements the logic above when customize_validation_message_from_context is true, so that just the existing (refactored) execution of the EmailValidator is executed when this option is disabled (so = false).

added notes from dev iteration feedbacks :
* maybe prefer just add classes or trait, not necessarly a service yet : member bundle already has a lot of services making it heavy to initialize, so better not create a service as a class, if no real reuse use case concrete yet;
* add needed comments for refactoring of existing code;
* manage optionally refactoring in another commit or leave it in a future ticket: the main point is to comment what is to be refactored (to not loose this knowledge).

}}

h2. Business test scenarios

{{collapse()


}}

h2. Dev phase test report

{{collapse()


}}

h2. Validation phase test report

{{collapse()


}}

h2. Technical tests scenarios

{{collapse()


}}


h2. Technical test report

{{collapse()


}}


----</new_value>
    </detail>
  </details>
</journal>
<journal id="638607">
  <user id="529" name="Franck D."/>
  <notes>"Technical analysis / design" completion from first dev/test iteration feedbacks.</notes>
  <created_on>2021-06-08T15:11:57Z</created_on>
  <private_notes>true</private_notes>
  <details type="array"/>
</journal>
<journal id="638612">
  <user id="529" name="Franck D."/>
  <notes/>
  <created_on>2021-06-08T15:26:05Z</created_on>
  <private_notes>false</private_notes>
  <details type="array">
    <detail property="attr" name="description">
      <old_value>{{ToC}}

h1. Requester request

_NB: technical level contents are annotated in italic notes delimited by &lt; and &gt;._
See note #67084#note-30 about such a case.
Goal of this tkt is to dev and deploy the solution described in section "Conclusion / décision" of this note.
In a word, here is the business rule to add to the email validator via this ticket :
* when the email is detected as invalid,
* if it is the email of an existing member, _&lt;= validated object retrieved from the validator context is (or inherits from) IdentityBase and its "actif" property is "O" or "J"&gt;_
* then the message sent back to the user/member is specifc to this context : it tells the user to the contact the customer support if he/she is sure his/her email is valid, otherwise change it for a valid one via the "My Account" page.

This business rule is to be applied only if option customize_validation_message_from_context is set. _&lt;= boolean option set to true&gt;_
Such an option can be set either :
* globally, _&lt;= a new customize_validation_message_from_context boolean parameter of the EmailValidator service set to true in services.yml&gt;_
* or on a case-by-case basis, _&lt;= a new customize_validation_message_from_context boolean option of Bilendi's Email constraint class&gt;_
* and the later always takes precedence over the former.

To illustrate such a new business rule : 
* in a cases like #66957 (tommasina.spampinato@virgilio.it) =&gt; it helps providing a quick fix once support has confirmed this email validity;
* and in cases like #68434 (farahnaouii@gmail:com) =&gt; it better guides the user on the proper page to fix such a mistake.

Furthermore, in order to monitor the occurence frequency of such a case, a message (with the invalid email value) is logged when such a case occurs (so only when the email is invalid AND ONLY if it is the email of an EXISTING member, as invalid member emails in registration scenarios are not in the targets scenarios to be taken into account, neither validation of email partners etc...).

@dev : see further technical design level requests in "Technical analysis / design" section.



----

h1. Dev notes

This section has been created with "this template":https://wiki.bilendi.net/doku.php/referentiel_de_pratiques:template_de_contenu#template_de_notes_de_dev

h2. Business analysis / solution

{{collapse()


}}

h2. Technical analysis / design

{{collapse()

STATUS : DRAFT

To complete the technical requirements written in the request, see the technical level requirements described in note #67084#note-30 / section "Conclusion / décision", for this solution :
* make a dedicated service to implement such a contextual message business rule,
...

The monitoring log action described in the request should not be implemented in such a service, whose purpose in to only implement the "message deduction business rule"; it should rather be implemented in the validator itself, so this leads to dividing the implementation of this new service in 4 new distinct actions/behaviors :
* if "email validation fails"
** _[new behavior]_  if customize_validation_message_from_context is true then :
*** _[new behavior]_ get the "failed validation context case" from context =&gt; this behavior resolves the "invalid case" from the validator context (namely the "object" of the context);
*** _[new behavior]_ add an "INFO log of the occurence of such case with the invalid email and the member id;
*** _[new behavior]_ get the violation message to be returned for this case;
** add the violation message in the context.

The "if customize_validation_message_from_context is true" is implemenyted by first checking if this email constraint is defiend in the incoming Email constraint object (= parameter of EmailValidator.validate() method);
if not then it checks the (new) customize_validation_message_from_context parameter of the EmailValidator service =&gt; this parameter is set to true in the member-bundles services.yml configuration of the EmailValidator service;
then one may define a class EmailValidatorContext  aside EmailValidator dedicated to resolving the validation case;
one may implement the "case" semantic  by an api of it like isExistingMemberCase() =&gt; so this class will just check that an "object" is in context and it is an object of "a member class" =&gt;  and return true only in this case;
as the current violation message implementation requires a refactoring for a long time, one may implement a dedicated class EmailValidatorMessage with an api setExistingMemberCaseMessage($constraintViolations) to implement this new case and another setDefaultCaseMessage($constraintViolations) to refactor the default case (set the default Sf invalid email message);
one also makes a getExistingMemberCaseLogMessage() returning a message consistant and unified with setExistingMemberCaseMessage, to be looged as an "INFO" log;
finally to ensure a loose coupling of the actual EmailValidator behavior and the customize_validation_message_from_context option, one can create a EmailValidatorContextRule service that implements the logic above when customize_validation_message_from_context is true, so that just the existing (refactored) execution of the EmailValidator is executed when this option is disabled (so = false).

added notes from dev iteration feedbacks :
* maybe prefer just add classes or trait, not necessarly a service yet : member bundle already has a lot of services making it heavy to initialize, so better not create a service as a class, if no real reuse use case concrete yet;
* add needed comments for refactoring of existing code;
* manage optionally refactoring in another commit or leave it in a future ticket: the main point is to comment what is to be refactored (to not loose this knowledge).

}}

h2. Business test scenarios

{{collapse()


}}

h2. Dev phase test report

{{collapse()


}}

h2. Validation phase test report

{{collapse()


}}

h2. Technical tests scenarios

{{collapse()


}}


h2. Technical test report

{{collapse()


}}


----</old_value>
      <new_value>{{ToC}}

h1. Requester request

_NB: technical level contents are annotated in italic notes delimited by &lt; and &gt;._
See note #67084#note-30 about such a case.
Goal of this tkt is to dev and deploy the solution described in section "Conclusion / décision" of this note.
In a word, here is the business rule to add to the email validator via this ticket :
* when the email is detected as invalid,
* if it is the email of an existing member, _&lt;= validated object retrieved from the validator context is (or inherits from) IdentityBase and its "actif" property is "O" or "J"&gt;_
* then the message sent back to the user/member is specifc to this context : it tells the user to the contact the customer support if he/she is sure his/her email is valid, otherwise change it for a valid one via the "My Account" page.

This business rule is to be applied only if option customize_validation_message_from_context is set. _&lt;= boolean option set to true&gt;_
Such an option can be set either :
* globally, _&lt;= a new customize_validation_message_from_context boolean parameter of the EmailValidator service set to true in services.yml&gt;_
* or on a case-by-case basis, _&lt;= a new customize_validation_message_from_context boolean option of Bilendi's Email constraint class&gt;_
* and the later always takes precedence over the former.

To illustrate such a new business rule : 
* in a cases like #66957 (tommasina.spampinato@virgilio.it) =&gt; it helps providing a quick fix once support has confirmed this email validity;
* and in cases like #68434 (farahnaouii@gmail:com) =&gt; it better guides the user on the proper page to fix such a mistake.

Furthermore, in order to monitor the occurence frequency of such a case, a message (with the invalid email value) is logged when such a case occurs (so only when the email is invalid AND ONLY if it is the email of an EXISTING member, as invalid member emails in registration scenarios are not in the targets scenarios to be taken into account, neither validation of email partners etc...).

@dev : see further technical design level requests in "Technical analysis / design" section.



----

h1. Dev notes

This section has been created with "this template":https://wiki.bilendi.net/doku.php/referentiel_de_pratiques:template_de_contenu#template_de_notes_de_dev

h2. Business analysis / solution

{{collapse()


}}

h2. Technical analysis / design

{{collapse()

STATUS : DRAFT

To complete the technical requirements written in the request, see the technical level requirements described in note #67084#note-30 / section "Conclusion / décision", for this solution :
* make a dedicated service to implement such a contextual message business rule,
...

The monitoring log action described in the request should not be implemented in such a service, whose purpose in to only implement the "message deduction business rule"; it should rather be implemented in the validator itself, so this leads to dividing the implementation of this new service in 4 new distinct actions/behaviors :
* if "email validation fails"
** _[new behavior]_  if customize_validation_message_from_context is true then :
*** _[new behavior]_ get the "failed validation context case" from context =&gt; this behavior resolves the "invalid case" from the validator context (namely the "object" of the context);
*** _[new behavior]_ add an "INFO log of the occurence of such case with the invalid email and the member id;
*** _[new behavior]_ get the violation message to be returned for this case;
** add the violation message in the context.

The "if customize_validation_message_from_context is true" is implemenyted by first checking if this email constraint is defiend in the incoming Email constraint object (= parameter of EmailValidator.validate() method);
if not then it checks the (new) customize_validation_message_from_context parameter of the EmailValidator service =&gt; this parameter is set to true in the member-bundles services.yml configuration of the EmailValidator service;
then one may define a class EmailValidatorContext  aside EmailValidator dedicated to resolving the validation case;
one may implement the "case" semantic  by an api of it like isExistingMemberCase() =&gt; so this class will just check that an "object" is in context and it is an object of "a member class" =&gt;  and return true only in this case;
as the current violation message implementation requires a refactoring for a long time, one may implement a dedicated class EmailValidatorMessage with an api setExistingMemberCaseMessage($constraintViolations) to implement this new case and another setDefaultCaseMessage($constraintViolations) to refactor the default case (set the default Sf invalid email message);
one also makes a getExistingMemberCaseLogMessage() returning a message consistant and unified with setExistingMemberCaseMessage, to be looged as an "INFO" log;
finally to ensure a loose coupling of the actual EmailValidator behavior and the customize_validation_message_from_context option, one can create a EmailValidatorContextRule service that implements the logic above when customize_validation_message_from_context is true, so that just the existing (refactored) execution of the EmailValidator is executed when this option is disabled (so = false).

added notes from dev iteration feedbacks :
* maybe prefer just add classes or trait, not necessarly a service yet : member bundle already has a lot of services making it heavy to initialize, so better not create a service as a class, if no real reuse use case concrete yet;
* add needed comments for refactoring of existing code;
* namely check if "addSource" is to be added to messages of Constraints Email, EmailBlacklist, EmailAccent and to class EmailValidatorMessage as described in comment of méthod : \Bilendi\MemberBundle\Validator\Constraints\EmailValidatorMessageManager::getTranslationMessages;
* manage optionally refactoring in another commit or leave it for a future ticket depending on delay/planning: the main point is to comment what is to be refactored (to not loose this knowledge).

}}

h2. Business test scenarios

{{collapse()


}}

h2. Dev phase test report

{{collapse()


}}

h2. Validation phase test report

{{collapse()


}}

h2. Technical tests scenarios

{{collapse()


}}


h2. Technical test report

{{collapse()


}}


----</new_value>
    </detail>
  </details>
</journal>
<journal id="638613">
  <user id="529" name="Franck D."/>
  <notes>"Technical analysis / design" completion from first dev/test iteration feedbacks of refactoring commenting and optionally done in a dedicated commit.</notes>
  <created_on>2021-06-08T15:26:05Z</created_on>
  <private_notes>true</private_notes>
  <details type="array"/>
</journal>
<journal id="638617">
  <user id="529" name="Franck D."/>
  <notes>Dev phase solution validation test report screenshots.</notes>
  <created_on>2021-06-08T15:42:21Z</created_on>
  <private_notes>false</private_notes>
  <details type="array">
    <detail property="attachment" name="98881">
      <old_value/>
      <new_value>Capture d’écran 2021-06-08 à 16.04.32.png</new_value>
    </detail>
    <detail property="attachment" name="98882">
      <old_value/>
      <new_value>Capture d’écran 2021-06-08 à 15.50.50.png</new_value>
    </detail>
    <detail property="attachment" name="98883">
      <old_value/>
      <new_value>Capture d’écran 2021-06-08 à 17.37.14.png</new_value>
    </detail>
  </details>
</journal>
<journal id="638618">
  <user id="529" name="Franck D."/>
  <notes>Removal in the request of the optional "case by case" setting of the customize_validation_message_from_context option, as after code review no case requiring a case by case setting of this option exists, so no real case to test it... let's add it if needed in a next ticket with a real test case.</notes>
  <created_on>2021-06-08T15:46:17Z</created_on>
  <private_notes>false</private_notes>
  <details type="array">
    <detail property="attr" name="description">
      <old_value>{{ToC}}

h1. Requester request

_NB: technical level contents are annotated in italic notes delimited by &lt; and &gt;._
See note #67084#note-30 about such a case.
Goal of this tkt is to dev and deploy the solution described in section "Conclusion / décision" of this note.
In a word, here is the business rule to add to the email validator via this ticket :
* when the email is detected as invalid,
* if it is the email of an existing member, _&lt;= validated object retrieved from the validator context is (or inherits from) IdentityBase and its "actif" property is "O" or "J"&gt;_
* then the message sent back to the user/member is specifc to this context : it tells the user to the contact the customer support if he/she is sure his/her email is valid, otherwise change it for a valid one via the "My Account" page.

This business rule is to be applied only if option customize_validation_message_from_context is set. _&lt;= boolean option set to true&gt;_
Such an option can be set either :
* globally, _&lt;= a new customize_validation_message_from_context boolean parameter of the EmailValidator service set to true in services.yml&gt;_
* or on a case-by-case basis, _&lt;= a new customize_validation_message_from_context boolean option of Bilendi's Email constraint class&gt;_
* and the later always takes precedence over the former.

To illustrate such a new business rule : 
* in a cases like #66957 (tommasina.spampinato@virgilio.it) =&gt; it helps providing a quick fix once support has confirmed this email validity;
* and in cases like #68434 (farahnaouii@gmail:com) =&gt; it better guides the user on the proper page to fix such a mistake.

Furthermore, in order to monitor the occurence frequency of such a case, a message (with the invalid email value) is logged when such a case occurs (so only when the email is invalid AND ONLY if it is the email of an EXISTING member, as invalid member emails in registration scenarios are not in the targets scenarios to be taken into account, neither validation of email partners etc...).

@dev : see further technical design level requests in "Technical analysis / design" section.



----

h1. Dev notes

This section has been created with "this template":https://wiki.bilendi.net/doku.php/referentiel_de_pratiques:template_de_contenu#template_de_notes_de_dev

h2. Business analysis / solution

{{collapse()


}}

h2. Technical analysis / design

{{collapse()

STATUS : DRAFT

To complete the technical requirements written in the request, see the technical level requirements described in note #67084#note-30 / section "Conclusion / décision", for this solution :
* make a dedicated service to implement such a contextual message business rule,
...

The monitoring log action described in the request should not be implemented in such a service, whose purpose in to only implement the "message deduction business rule"; it should rather be implemented in the validator itself, so this leads to dividing the implementation of this new service in 4 new distinct actions/behaviors :
* if "email validation fails"
** _[new behavior]_  if customize_validation_message_from_context is true then :
*** _[new behavior]_ get the "failed validation context case" from context =&gt; this behavior resolves the "invalid case" from the validator context (namely the "object" of the context);
*** _[new behavior]_ add an "INFO log of the occurence of such case with the invalid email and the member id;
*** _[new behavior]_ get the violation message to be returned for this case;
** add the violation message in the context.

The "if customize_validation_message_from_context is true" is implemenyted by first checking if this email constraint is defiend in the incoming Email constraint object (= parameter of EmailValidator.validate() method);
if not then it checks the (new) customize_validation_message_from_context parameter of the EmailValidator service =&gt; this parameter is set to true in the member-bundles services.yml configuration of the EmailValidator service;
then one may define a class EmailValidatorContext  aside EmailValidator dedicated to resolving the validation case;
one may implement the "case" semantic  by an api of it like isExistingMemberCase() =&gt; so this class will just check that an "object" is in context and it is an object of "a member class" =&gt;  and return true only in this case;
as the current violation message implementation requires a refactoring for a long time, one may implement a dedicated class EmailValidatorMessage with an api setExistingMemberCaseMessage($constraintViolations) to implement this new case and another setDefaultCaseMessage($constraintViolations) to refactor the default case (set the default Sf invalid email message);
one also makes a getExistingMemberCaseLogMessage() returning a message consistant and unified with setExistingMemberCaseMessage, to be looged as an "INFO" log;
finally to ensure a loose coupling of the actual EmailValidator behavior and the customize_validation_message_from_context option, one can create a EmailValidatorContextRule service that implements the logic above when customize_validation_message_from_context is true, so that just the existing (refactored) execution of the EmailValidator is executed when this option is disabled (so = false).

added notes from dev iteration feedbacks :
* maybe prefer just add classes or trait, not necessarly a service yet : member bundle already has a lot of services making it heavy to initialize, so better not create a service as a class, if no real reuse use case concrete yet;
* add needed comments for refactoring of existing code;
* namely check if "addSource" is to be added to messages of Constraints Email, EmailBlacklist, EmailAccent and to class EmailValidatorMessage as described in comment of méthod : \Bilendi\MemberBundle\Validator\Constraints\EmailValidatorMessageManager::getTranslationMessages;
* manage optionally refactoring in another commit or leave it for a future ticket depending on delay/planning: the main point is to comment what is to be refactored (to not loose this knowledge).

}}

h2. Business test scenarios

{{collapse()


}}

h2. Dev phase test report

{{collapse()


}}

h2. Validation phase test report

{{collapse()


}}

h2. Technical tests scenarios

{{collapse()


}}


h2. Technical test report

{{collapse()


}}


----</old_value>
      <new_value>{{ToC}}

h1. Requester request

_NB: technical level contents are annotated in italic notes delimited by &lt; and &gt;._
See note #67084#note-30 about such a case.
Goal of this tkt is to dev and deploy the solution described in section "Conclusion / décision" of this note.
In a word, here is the business rule to add to the email validator via this ticket :
* when the email is detected as invalid,
* if it is the email of an existing member, _&lt;= validated object retrieved from the validator context is (or inherits from) IdentityBase and its "actif" property is "O" or "J"&gt;_
* then the message sent back to the user/member is specifc to this context : it tells the user to the contact the customer support if he/she is sure his/her email is valid, otherwise change it for a valid one via the "My Account" page.

This business rule is to be applied only if option customize_validation_message_from_context is set for the app (defaults to true in the member bundle). _&lt;= boolean option set to true&gt;_


To illustrate such a new business rule : 
* in a cases like #66957 (tommasina.spampinato@virgilio.it) =&gt; it helps providing a quick fix once support has confirmed this email validity;
* and in cases like #68434 (farahnaouii@gmail:com) =&gt; it better guides the user on the proper page to fix such a mistake.

Furthermore, in order to monitor the occurence frequency of such a case, a message (with the invalid email value) is logged when such a case occurs (so only when the email is invalid AND ONLY if it is the email of an EXISTING member, as invalid member emails in registration scenarios are not in the targets scenarios to be taken into account, neither validation of email partners etc...).

@dev : see further technical design level requests in "Technical analysis / design" section.



----

h1. Dev notes

This section has been created with "this template":https://wiki.bilendi.net/doku.php/referentiel_de_pratiques:template_de_contenu#template_de_notes_de_dev

h2. Business analysis / solution

{{collapse()


}}

h2. Technical analysis / design

{{collapse()

STATUS : DRAFT

To complete the technical requirements written in the request, see the technical level requirements described in note #67084#note-30 / section "Conclusion / décision", for this solution :
* make a dedicated service to implement such a contextual message business rule,
...

The monitoring log action described in the request should not be implemented in such a service, whose purpose in to only implement the "message deduction business rule"; it should rather be implemented in the validator itself, so this leads to dividing the implementation of this new service in 4 new distinct actions/behaviors :
* if "email validation fails"
** _[new behavior]_  if customize_validation_message_from_context is true then :
*** _[new behavior]_ get the "failed validation context case" from context =&gt; this behavior resolves the "invalid case" from the validator context (namely the "object" of the context);
*** _[new behavior]_ add an "INFO log of the occurence of such case with the invalid email and the member id;
*** _[new behavior]_ get the violation message to be returned for this case;
** add the violation message in the context.

The "if customize_validation_message_from_context is true" is implemenyted by first checking if this email constraint is defiend in the incoming Email constraint object (= parameter of EmailValidator.validate() method);
if not then it checks the (new) customize_validation_message_from_context parameter of the EmailValidator service =&gt; this parameter is set to true in the member-bundles services.yml configuration of the EmailValidator service;
then one may define a class EmailValidatorContext  aside EmailValidator dedicated to resolving the validation case;
one may implement the "case" semantic  by an api of it like isExistingMemberCase() =&gt; so this class will just check that an "object" is in context and it is an object of "a member class" =&gt;  and return true only in this case;
as the current violation message implementation requires a refactoring for a long time, one may implement a dedicated class EmailValidatorMessage with an api setExistingMemberCaseMessage($constraintViolations) to implement this new case and another setDefaultCaseMessage($constraintViolations) to refactor the default case (set the default Sf invalid email message);
one also makes a getExistingMemberCaseLogMessage() returning a message consistant and unified with setExistingMemberCaseMessage, to be looged as an "INFO" log;
finally to ensure a loose coupling of the actual EmailValidator behavior and the customize_validation_message_from_context option, one can create a EmailValidatorContextRule service that implements the logic above when customize_validation_message_from_context is true, so that just the existing (refactored) execution of the EmailValidator is executed when this option is disabled (so = false).

added notes from dev iteration feedbacks :
* maybe prefer just add classes or trait, not necessarly a service yet : member bundle already has a lot of services making it heavy to initialize, so better not create a service as a class, if no real reuse use case concrete yet;
* add needed comments for refactoring of existing code;
* namely check if "addSource" is to be added to messages of Constraints Email, EmailBlacklist, EmailAccent and to class EmailValidatorMessage as described in comment of méthod : \Bilendi\MemberBundle\Validator\Constraints\EmailValidatorMessageManager::getTranslationMessages;
* manage optionally refactoring in another commit or leave it for a future ticket depending on delay/planning: the main point is to comment what is to be refactored (to not loose this knowledge).

}}

h2. Business test scenarios

{{collapse()


}}

h2. Dev phase test report

{{collapse()


}}

h2. Validation phase test report

{{collapse()


}}

h2. Technical tests scenarios

{{collapse()


}}


h2. Technical test report

{{collapse()


}}


----</new_value>
    </detail>
  </details>
</journal>
<journal id="638619">
  <user id="529" name="Franck D."/>
  <notes/>
  <created_on>2021-06-08T15:47:20Z</created_on>
  <private_notes>false</private_notes>
  <details type="array">
    <detail property="attr" name="description">
      <old_value>{{ToC}}

h1. Requester request

_NB: technical level contents are annotated in italic notes delimited by &lt; and &gt;._
See note #67084#note-30 about such a case.
Goal of this tkt is to dev and deploy the solution described in section "Conclusion / décision" of this note.
In a word, here is the business rule to add to the email validator via this ticket :
* when the email is detected as invalid,
* if it is the email of an existing member, _&lt;= validated object retrieved from the validator context is (or inherits from) IdentityBase and its "actif" property is "O" or "J"&gt;_
* then the message sent back to the user/member is specifc to this context : it tells the user to the contact the customer support if he/she is sure his/her email is valid, otherwise change it for a valid one via the "My Account" page.

This business rule is to be applied only if option customize_validation_message_from_context is set for the app (defaults to true in the member bundle). _&lt;= boolean option set to true&gt;_


To illustrate such a new business rule : 
* in a cases like #66957 (tommasina.spampinato@virgilio.it) =&gt; it helps providing a quick fix once support has confirmed this email validity;
* and in cases like #68434 (farahnaouii@gmail:com) =&gt; it better guides the user on the proper page to fix such a mistake.

Furthermore, in order to monitor the occurence frequency of such a case, a message (with the invalid email value) is logged when such a case occurs (so only when the email is invalid AND ONLY if it is the email of an EXISTING member, as invalid member emails in registration scenarios are not in the targets scenarios to be taken into account, neither validation of email partners etc...).

@dev : see further technical design level requests in "Technical analysis / design" section.



----

h1. Dev notes

This section has been created with "this template":https://wiki.bilendi.net/doku.php/referentiel_de_pratiques:template_de_contenu#template_de_notes_de_dev

h2. Business analysis / solution

{{collapse()


}}

h2. Technical analysis / design

{{collapse()

STATUS : DRAFT

To complete the technical requirements written in the request, see the technical level requirements described in note #67084#note-30 / section "Conclusion / décision", for this solution :
* make a dedicated service to implement such a contextual message business rule,
...

The monitoring log action described in the request should not be implemented in such a service, whose purpose in to only implement the "message deduction business rule"; it should rather be implemented in the validator itself, so this leads to dividing the implementation of this new service in 4 new distinct actions/behaviors :
* if "email validation fails"
** _[new behavior]_  if customize_validation_message_from_context is true then :
*** _[new behavior]_ get the "failed validation context case" from context =&gt; this behavior resolves the "invalid case" from the validator context (namely the "object" of the context);
*** _[new behavior]_ add an "INFO log of the occurence of such case with the invalid email and the member id;
*** _[new behavior]_ get the violation message to be returned for this case;
** add the violation message in the context.

The "if customize_validation_message_from_context is true" is implemenyted by first checking if this email constraint is defiend in the incoming Email constraint object (= parameter of EmailValidator.validate() method);
if not then it checks the (new) customize_validation_message_from_context parameter of the EmailValidator service =&gt; this parameter is set to true in the member-bundles services.yml configuration of the EmailValidator service;
then one may define a class EmailValidatorContext  aside EmailValidator dedicated to resolving the validation case;
one may implement the "case" semantic  by an api of it like isExistingMemberCase() =&gt; so this class will just check that an "object" is in context and it is an object of "a member class" =&gt;  and return true only in this case;
as the current violation message implementation requires a refactoring for a long time, one may implement a dedicated class EmailValidatorMessage with an api setExistingMemberCaseMessage($constraintViolations) to implement this new case and another setDefaultCaseMessage($constraintViolations) to refactor the default case (set the default Sf invalid email message);
one also makes a getExistingMemberCaseLogMessage() returning a message consistant and unified with setExistingMemberCaseMessage, to be looged as an "INFO" log;
finally to ensure a loose coupling of the actual EmailValidator behavior and the customize_validation_message_from_context option, one can create a EmailValidatorContextRule service that implements the logic above when customize_validation_message_from_context is true, so that just the existing (refactored) execution of the EmailValidator is executed when this option is disabled (so = false).

added notes from dev iteration feedbacks :
* maybe prefer just add classes or trait, not necessarly a service yet : member bundle already has a lot of services making it heavy to initialize, so better not create a service as a class, if no real reuse use case concrete yet;
* add needed comments for refactoring of existing code;
* namely check if "addSource" is to be added to messages of Constraints Email, EmailBlacklist, EmailAccent and to class EmailValidatorMessage as described in comment of méthod : \Bilendi\MemberBundle\Validator\Constraints\EmailValidatorMessageManager::getTranslationMessages;
* manage optionally refactoring in another commit or leave it for a future ticket depending on delay/planning: the main point is to comment what is to be refactored (to not loose this knowledge).

}}

h2. Business test scenarios

{{collapse()


}}

h2. Dev phase test report

{{collapse()


}}

h2. Validation phase test report

{{collapse()


}}

h2. Technical tests scenarios

{{collapse()


}}


h2. Technical test report

{{collapse()


}}


----</old_value>
      <new_value>{{ToC}}

h1. Requester request

_NB: technical level contents are annotated in italic notes delimited by &lt; and &gt;._
See note #67084#note-30 about such a case.
Goal of this tkt is to dev and deploy the solution described in section "Conclusion / décision" of this note.
In a word, here is the business rule to add to the email validator via this ticket :
* when the email is detected as invalid,
* if it is the email of an existing member, _&lt;= validated object retrieved from the validator context is (or inherits from) IdentityBase and its "actif" property is "O" or "J"&gt;_
* then the message sent back to the user/member is specifc to this context : it tells the user to the contact the customer support if he/she is sure his/her email is valid, otherwise change it for a valid one via the "My Account" page.

This business rule is to be applied only if option customize_validation_message_from_context is set for the app (defaults to true in the member bundle). _&lt;= boolean yaml parameter set to true&gt;_


To illustrate such a new business rule : 
* in a cases like #66957 (tommasina.spampinato@virgilio.it) =&gt; it helps providing a quick fix once support has confirmed this email validity;
* and in cases like #68434 (farahnaouii@gmail:com) =&gt; it better guides the user on the proper page to fix such a mistake.

Furthermore, in order to monitor the occurence frequency of such a case, a message (with the invalid email value) is logged when such a case occurs (so only when the email is invalid AND ONLY if it is the email of an EXISTING member, as invalid member emails in registration scenarios are not in the targets scenarios to be taken into account, neither validation of email partners etc...).

@dev : see further technical design level requests in "Technical analysis / design" section.



----

h1. Dev notes

This section has been created with "this template":https://wiki.bilendi.net/doku.php/referentiel_de_pratiques:template_de_contenu#template_de_notes_de_dev

h2. Business analysis / solution

{{collapse()


}}

h2. Technical analysis / design

{{collapse()

STATUS : DRAFT

To complete the technical requirements written in the request, see the technical level requirements described in note #67084#note-30 / section "Conclusion / décision", for this solution :
* make a dedicated service to implement such a contextual message business rule,
...

The monitoring log action described in the request should not be implemented in such a service, whose purpose in to only implement the "message deduction business rule"; it should rather be implemented in the validator itself, so this leads to dividing the implementation of this new service in 4 new distinct actions/behaviors :
* if "email validation fails"
** _[new behavior]_  if customize_validation_message_from_context is true then :
*** _[new behavior]_ get the "failed validation context case" from context =&gt; this behavior resolves the "invalid case" from the validator context (namely the "object" of the context);
*** _[new behavior]_ add an "INFO log of the occurence of such case with the invalid email and the member id;
*** _[new behavior]_ get the violation message to be returned for this case;
** add the violation message in the context.

The "if customize_validation_message_from_context is true" is implemenyted by first checking if this email constraint is defiend in the incoming Email constraint object (= parameter of EmailValidator.validate() method);
if not then it checks the (new) customize_validation_message_from_context parameter of the EmailValidator service =&gt; this parameter is set to true in the member-bundles services.yml configuration of the EmailValidator service;
then one may define a class EmailValidatorContext  aside EmailValidator dedicated to resolving the validation case;
one may implement the "case" semantic  by an api of it like isExistingMemberCase() =&gt; so this class will just check that an "object" is in context and it is an object of "a member class" =&gt;  and return true only in this case;
as the current violation message implementation requires a refactoring for a long time, one may implement a dedicated class EmailValidatorMessage with an api setExistingMemberCaseMessage($constraintViolations) to implement this new case and another setDefaultCaseMessage($constraintViolations) to refactor the default case (set the default Sf invalid email message);
one also makes a getExistingMemberCaseLogMessage() returning a message consistant and unified with setExistingMemberCaseMessage, to be looged as an "INFO" log;
finally to ensure a loose coupling of the actual EmailValidator behavior and the customize_validation_message_from_context option, one can create a EmailValidatorContextRule service that implements the logic above when customize_validation_message_from_context is true, so that just the existing (refactored) execution of the EmailValidator is executed when this option is disabled (so = false).

added notes from dev iteration feedbacks :
* maybe prefer just add classes or trait, not necessarly a service yet : member bundle already has a lot of services making it heavy to initialize, so better not create a service as a class, if no real reuse use case concrete yet;
* add needed comments for refactoring of existing code;
* namely check if "addSource" is to be added to messages of Constraints Email, EmailBlacklist, EmailAccent and to class EmailValidatorMessage as described in comment of méthod : \Bilendi\MemberBundle\Validator\Constraints\EmailValidatorMessageManager::getTranslationMessages;
* manage optionally refactoring in another commit or leave it for a future ticket depending on delay/planning: the main point is to comment what is to be refactored (to not loose this knowledge).

}}

h2. Business test scenarios

{{collapse()


}}

h2. Dev phase test report

{{collapse()


}}

h2. Validation phase test report

{{collapse()


}}

h2. Technical tests scenarios

{{collapse()


}}


h2. Technical test report

{{collapse()


}}


----</new_value>
    </detail>
  </details>
</journal>
<journal id="638620">
  <user id="529" name="Franck D."/>
  <notes>technical annotation formulation fix...</notes>
  <created_on>2021-06-08T15:47:20Z</created_on>
  <private_notes>true</private_notes>
  <details type="array"/>
</journal>
<journal id="638946">
  <user id="529" name="Franck D."/>
  <notes/>
  <created_on>2021-06-10T13:06:07Z</created_on>
  <private_notes>false</private_notes>
  <details type="array">
    <detail property="attr" name="description">
      <old_value>{{ToC}}

h1. Requester request

_NB: technical level contents are annotated in italic notes delimited by &lt; and &gt;._
See note #67084#note-30 about such a case.
Goal of this tkt is to dev and deploy the solution described in section "Conclusion / décision" of this note.
In a word, here is the business rule to add to the email validator via this ticket :
* when the email is detected as invalid,
* if it is the email of an existing member, _&lt;= validated object retrieved from the validator context is (or inherits from) IdentityBase and its "actif" property is "O" or "J"&gt;_
* then the message sent back to the user/member is specifc to this context : it tells the user to the contact the customer support if he/she is sure his/her email is valid, otherwise change it for a valid one via the "My Account" page.

This business rule is to be applied only if option customize_validation_message_from_context is set for the app (defaults to true in the member bundle). _&lt;= boolean yaml parameter set to true&gt;_


To illustrate such a new business rule : 
* in a cases like #66957 (tommasina.spampinato@virgilio.it) =&gt; it helps providing a quick fix once support has confirmed this email validity;
* and in cases like #68434 (farahnaouii@gmail:com) =&gt; it better guides the user on the proper page to fix such a mistake.

Furthermore, in order to monitor the occurence frequency of such a case, a message (with the invalid email value) is logged when such a case occurs (so only when the email is invalid AND ONLY if it is the email of an EXISTING member, as invalid member emails in registration scenarios are not in the targets scenarios to be taken into account, neither validation of email partners etc...).

@dev : see further technical design level requests in "Technical analysis / design" section.



----

h1. Dev notes

This section has been created with "this template":https://wiki.bilendi.net/doku.php/referentiel_de_pratiques:template_de_contenu#template_de_notes_de_dev

h2. Business analysis / solution

{{collapse()


}}

h2. Technical analysis / design

{{collapse()

STATUS : DRAFT

To complete the technical requirements written in the request, see the technical level requirements described in note #67084#note-30 / section "Conclusion / décision", for this solution :
* make a dedicated service to implement such a contextual message business rule,
...

The monitoring log action described in the request should not be implemented in such a service, whose purpose in to only implement the "message deduction business rule"; it should rather be implemented in the validator itself, so this leads to dividing the implementation of this new service in 4 new distinct actions/behaviors :
* if "email validation fails"
** _[new behavior]_  if customize_validation_message_from_context is true then :
*** _[new behavior]_ get the "failed validation context case" from context =&gt; this behavior resolves the "invalid case" from the validator context (namely the "object" of the context);
*** _[new behavior]_ add an "INFO log of the occurence of such case with the invalid email and the member id;
*** _[new behavior]_ get the violation message to be returned for this case;
** add the violation message in the context.

The "if customize_validation_message_from_context is true" is implemenyted by first checking if this email constraint is defiend in the incoming Email constraint object (= parameter of EmailValidator.validate() method);
if not then it checks the (new) customize_validation_message_from_context parameter of the EmailValidator service =&gt; this parameter is set to true in the member-bundles services.yml configuration of the EmailValidator service;
then one may define a class EmailValidatorContext  aside EmailValidator dedicated to resolving the validation case;
one may implement the "case" semantic  by an api of it like isExistingMemberCase() =&gt; so this class will just check that an "object" is in context and it is an object of "a member class" =&gt;  and return true only in this case;
as the current violation message implementation requires a refactoring for a long time, one may implement a dedicated class EmailValidatorMessage with an api setExistingMemberCaseMessage($constraintViolations) to implement this new case and another setDefaultCaseMessage($constraintViolations) to refactor the default case (set the default Sf invalid email message);
one also makes a getExistingMemberCaseLogMessage() returning a message consistant and unified with setExistingMemberCaseMessage, to be looged as an "INFO" log;
finally to ensure a loose coupling of the actual EmailValidator behavior and the customize_validation_message_from_context option, one can create a EmailValidatorContextRule service that implements the logic above when customize_validation_message_from_context is true, so that just the existing (refactored) execution of the EmailValidator is executed when this option is disabled (so = false).

added notes from dev iteration feedbacks :
* maybe prefer just add classes or trait, not necessarly a service yet : member bundle already has a lot of services making it heavy to initialize, so better not create a service as a class, if no real reuse use case concrete yet;
* add needed comments for refactoring of existing code;
* namely check if "addSource" is to be added to messages of Constraints Email, EmailBlacklist, EmailAccent and to class EmailValidatorMessage as described in comment of méthod : \Bilendi\MemberBundle\Validator\Constraints\EmailValidatorMessageManager::getTranslationMessages;
* manage optionally refactoring in another commit or leave it for a future ticket depending on delay/planning: the main point is to comment what is to be refactored (to not loose this knowledge).

}}

h2. Business test scenarios

{{collapse()


}}

h2. Dev phase test report

{{collapse()


}}

h2. Validation phase test report

{{collapse()


}}

h2. Technical tests scenarios

{{collapse()


}}


h2. Technical test report

{{collapse()


}}


----</old_value>
      <new_value>{{ToC}}

h1. Requester request

_NB: technical level contents are annotated in italic notes delimited by &lt; and &gt;._
See note #67084#note-30 about such a case.
Goal of this tkt is to dev and deploy the solution described in section "Conclusion / décision" of this note.
In a word, here is the business rule to add to the email validator via this ticket :
* when the email is detected as invalid,
* if it is the email of an existing member, _&lt;= validated object retrieved from the validator context is (or inherits from) IdentityBase and its "actif" property is "O" or "J"&gt;_
* then the message sent back to the user/member is specifc to this context : it tells the user to the contact the customer support if he/she is sure his/her email is valid, otherwise change it for a valid one via the "My Account" page.

This business rule is to be applied only if option customize_validation_message_from_context is set for the app (defaults to true in the member bundle). _&lt;= boolean yaml parameter set to true&gt;_


To illustrate such a new business rule : 
* in a cases like #66957 (tommasina.spampinato@virgilio.it) =&gt; it helps providing a quick fix once support has confirmed this email validity;
* and in cases like #68434 (farahnaouii@gmail:com) =&gt; it better guides the user on the proper page to fix such a mistake.

Furthermore, in order to monitor the occurence frequency of such a case, a message (with the invalid email value) is logged when such a case occurs (so only when the email is invalid AND ONLY if it is the email of an EXISTING member, as invalid member emails in registration scenarios are not in the targets scenarios to be taken into account, neither validation of email partners etc...).

@dev : see further technical design level requests in "Technical analysis / design" section.



----

h1. Dev notes

This section has been created with "this template":https://wiki.bilendi.net/doku.php/referentiel_de_pratiques:template_de_contenu#template_de_notes_de_dev

h2. Business analysis / solution

{{collapse()


}}

h2. Technical analysis / design

{{collapse()

STATUS : WIP

To complete the technical requirements written in the request, see the technical level requirements described in note #67084#note-30 / section "Conclusion / décision", for this solution :
* make a dedicated service to implement such a contextual message business rule,
...

The monitoring log action described in the request should not be implemented in such a service, whose purpose in to only implement the "message deduction business rule"; it should rather be implemented in the validator itself, so this leads to dividing the implementation of this new service in 4 new distinct actions/behaviors :
* if "email validation fails"
** _[new behavior]_  if customize_validation_message_from_context is true then :
*** _[new behavior]_ get the "failed validation context case" from context =&gt; this behavior resolves the "invalid case" from the validator context (namely the "object" of the context);
*** _[new behavior]_ add an "INFO log of the occurence of such case with the invalid email and the member id;
*** _[new behavior]_ get the violation message to be returned for this case;
** add the violation message in the context.

The "if customize_validation_message_from_context is true" is implemenyted by first checking if this email constraint is defiend in the incoming Email constraint object (= parameter of EmailValidator.validate() method);
if not then it checks the (new) customize_validation_message_from_context parameter of the EmailValidator service =&gt; this parameter is set to true in the member-bundles services.yml configuration of the EmailValidator service;
then one may define a class EmailValidatorContext  aside EmailValidator dedicated to resolving the validation case;
one may implement the "case" semantic  by an api of it like isExistingMemberCase() =&gt; so this class will just check that an "object" is in context and it is an object of "a member class" =&gt;  and return true only in this case;
as the current violation message implementation requires a refactoring for a long time, one may implement a dedicated class EmailValidatorMessage with an api setExistingMemberCaseMessage($constraintViolations) to implement this new case and another setDefaultCaseMessage($constraintViolations) to refactor the default case (set the default Sf invalid email message);
one also makes a getExistingMemberCaseLogMessage() returning a message consistant and unified with setExistingMemberCaseMessage, to be looged as an "INFO" log;
finally to ensure a loose coupling of the actual EmailValidator behavior and the customize_validation_message_from_context option, one can create a EmailValidatorContextRule service that implements the logic above when customize_validation_message_from_context is true, so that just the existing (refactored) execution of the EmailValidator is executed when this option is disabled (so = false).

added notes from dev iteration feedbacks :
* maybe prefer just add classes or trait, not necessarly a service yet : member bundle already has a lot of services making it heavy to initialize, so better not create a service as a class, if no real reuse use case concrete yet;
* add needed comments for refactoring of existing code;
* namely check if "addSource" is to be added to messages of Constraints Email, EmailBlacklist, EmailAccent and to class EmailValidatorMessage as described in comment of méthod : \Bilendi\MemberBundle\Validator\Constraints\EmailValidatorMessageManager::getTranslationMessages;
* manage optionally refactoring in another commit or leave it for a future ticket depending on delay/planning: the main point is to comment what is to be refactored (to not loose this knowledge).
* one also needs to check which of the following change email scenario alternatives customization forms are really used and cover them by a test if they are impacted by this change : &lt;pre&gt;
./pcp/src/AppBundle/Form/ChangeEmailType.php
./mpz/src/AppBundle/Form/Account/ChangeEmailType.php
./ivx/src/AppBundle/Form/Account/ChangeEmailType.php
./m3panel/src/AppBundle/Form/Account/ChangeEmailType.php
./baxi/src/AppBundle/Form/ChangeEmail/ChangeEmailType.php =&gt; discussion in wip about it on baxi chan =&gt; at date : no need to further test baxi as it excutes the same "member-bundle" scenario as mxm, if ever (from this discussion) an alternate change email scenario exists, then if this scenario si blocked because the email became invalid after email validation rules update, then the user can still fall back to the "member-bundle" scenario to fix his/her email.

&lt;/pre&gt;

}}

h2. Business test scenarios

{{collapse()

STATUS : WIP =&gt; see "Technical analysis / design" wection.

The scenarios below have to be performed at least on mxm and mpz to cover both non customized and customized email change scenario cases, combined to the "with and without date of birth check" alternatives : 
* mxm has no customization of the email change scenarios and executes with the "date of birth check" alternative,
* mpz has a customization of the email change scenarios  and executes with the "date of birth check" alternative,
* mxm with the 'change_email_request' configuration option removed, has no customization of the email change scenarios  and executes without the "date of birth check" alternative.


Non regression solution test scenarios with valid member email in db :
* the user has a valid email (f.delahaye+test7@bilendi.com);
* the update of a field from personal info form (lastname 'Galliot' changed for 'Galliott') works =&gt; OK or KO ?;
** same scenario from CCC =&gt; OK or KO ?
* test of validation of "gdpr acceptance"  form =&gt; OK or KO ?;
* test of validation of "unsubscribe"  form =&gt; OK or KO ?;
* test change email scenario, with date of birth check alternative, with a new invalid email =&gt; OK or KO ? ( new email f.delahaye+test8@bilendi:com);
* test change email scenario, with date of birth check alternative, with a new valid email =&gt; OK or KO ? ( new email f.delahaye+test8@bilendi.com);
* test change email scenario, without date of birth check alternative, with a new invalid email =&gt; OK or KO ? ( new email f.delahaye+test10@bilendi:com);
** same scenario from CCC =&gt; OK or KO ?
* test change email scenario, without date of birth check alternative, with a new valid email =&gt; OK or KO ? ( new email f.delahaye+test10@bilendi.com);
** same scenario from CCC =&gt; OK or KO ?


Correction solution test scenarios with an invalid member email in db, after new email validation rule deployed :
* a new email validation rule, that forbids email local part ending with "+test10" is deployed =&gt; then the email f.delahaye+test10@bilendi.com of the previous test case member has become invalid;
* the update of a field from personal info form (lastname 'Galliot' changed for 'Galliott') displays the expected invalid email message =&gt; OK or KO ?;
** same scenario from CCC =&gt; OK or KO ?
* test of validation of "gdpr accepatnce"  form displays the expected invalid email message =&gt; OK or KO ?;
* test of validation of "unsubscribe"  form displays the expected invalid email message =&gt; OK or KO ?;
* test change email scenario, with date of birth check alternative, with a new invalid email =&gt; displays the proper invalid email message =&gt; OK or KO ? ( new email f.delahaye+test8@bilendi:com);
* test change email scenario, with date of birth check alternative, with a new valid email =&gt; displays the proper invalid email message =&gt; OK or KO ? ( new email f.delahaye+test8@bilendi.com);
* test change email scenario, without date of birth check alternative, with a new invalid email =&gt; displays the proper invalid email message =&gt; OK or KO ? ( new email f.delahaye+test10@bilendi:com);
** same scenario from CCC =&gt; OK or KO ?
* test change email scenario, without date of birth check alternative, with a new valid email =&gt; displays the proper invalid email message =&gt; OK or KO ? ( new email f.delahaye+test10@bilendi.com);
** same scenario from CCC =&gt; OK or KO ?


}}

h2. Dev phase test report

{{collapse()


}}

h2. Validation phase test report

{{collapse()


}}

h2. Technical tests scenarios

{{collapse()


}}


h2. Technical test report

{{collapse()


}}


----</new_value>
    </detail>
  </details>
</journal>
<journal id="638947">
  <user id="529" name="Franck D."/>
  <notes>WIP status on "Technical analysis / design" and "Business test scenarios" sections before switching to other tkts reviews;
CCC scenario change email has been checked _(concerned Controller action : complaint-bundle::CccContactController::validateOrUpdateContactAction)_, and shouldn't be impacted as it directly validate the new email, not the existing one in db (yet non reg test of it should confirm);
branch not committed yet =&gt; to be commited at the end of the remaining tech diag wip actions depending on new cases to cover or not (namely cases from customized change email scenarios not yet discovered).</notes>
  <created_on>2021-06-10T13:06:07Z</created_on>
  <private_notes>true</private_notes>
  <details type="array"/>
</journal>
<journal id="639050">
  <user id="529" name="Franck D."/>
  <notes>These 3 change email customization form types:
&lt;pre&gt;
./mpz/src/AppBundle/Form/Account/ChangeEmailType.php
./ivx/src/AppBundle/Form/Account/ChangeEmailType.php
./m3panel/src/AppBundle/Form/Account/ChangeEmailType.php
&lt;/pre&gt;

share similar changes with their member bundle version (see attached screenshots).

Furthermore these 3 customizations do not integrate the "birth date check" in the email change request scenario, whereas
the 'change_email_request' option is configured on these apps, leading to using the member bundle's 'ChangeRequestForm' form type integrating the "birth date check", instead of these customizations.

Conclusion is that a refactoring ticket is wished to either remove these customizations if they are obsolete, or factorize them in the member bundle, as an EmailChangeType variant of the default one.</notes>
  <created_on>2021-06-10T17:04:38Z</created_on>
  <private_notes>false</private_notes>
  <details type="array">
    <detail property="attachment" name="98923">
      <old_value/>
      <new_value>Capture d’écran 2021-06-10 à 18.43.18.png</new_value>
    </detail>
    <detail property="attachment" name="98921">
      <old_value/>
      <new_value>Capture d’écran 2021-06-10 à 18.41.25.png</new_value>
    </detail>
    <detail property="attachment" name="98922">
      <old_value/>
      <new_value>Capture d’écran 2021-06-10 à 18.42.32.png</new_value>
    </detail>
  </details>
</journal>
<journal id="639052">
  <user id="529" name="Franck D."/>
  <notes>These 3 change email customization form types:
&lt;pre&gt;
./pcp/src/AppBundle/Form/ChangeEmailType.php
./baxi/src/AppBundle/Form/ChangeEmail/ChangeEmailType.php 
&lt;/pre&gt;

share similar changes with their member bundle version (see attached screenshots).

Furthermore these 2 customizations do not integrate the "birth date check" in the email change request scenario, whereas
the 'change_email_request' option is configured on these apps, leading to using the member bundle's 'ChangeRequestForm' form type integrating the "birth date check", instead of these customizations.

Conclusion is that a refactoring ticket is wished to either remove these customizations if they are obsolete, or factorize them in the member bundle, as an EmailChangeType variant of the default one.</notes>
  <created_on>2021-06-10T17:08:11Z</created_on>
  <private_notes>false</private_notes>
  <details type="array">
    <detail property="attachment" name="98926">
      <old_value/>
      <new_value>Capture d’écran 2021-06-10 à 18.49.14.png</new_value>
    </detail>
    <detail property="attachment" name="98925">
      <old_value/>
      <new_value>Capture d’écran 2021-06-10 à 18.49.40.png</new_value>
    </detail>
  </details>
</journal>
<journal id="639112">
  <user id="529" name="Franck D."/>
  <notes>Adds wip of dev phase test report on mxm app.</notes>
  <created_on>2021-06-11T09:01:44Z</created_on>
  <private_notes>false</private_notes>
  <details type="array">
    <detail property="attr" name="description">
      <old_value>{{ToC}}

h1. Requester request

_NB: technical level contents are annotated in italic notes delimited by &lt; and &gt;._
See note #67084#note-30 about such a case.
Goal of this tkt is to dev and deploy the solution described in section "Conclusion / décision" of this note.
In a word, here is the business rule to add to the email validator via this ticket :
* when the email is detected as invalid,
* if it is the email of an existing member, _&lt;= validated object retrieved from the validator context is (or inherits from) IdentityBase and its "actif" property is "O" or "J"&gt;_
* then the message sent back to the user/member is specifc to this context : it tells the user to the contact the customer support if he/she is sure his/her email is valid, otherwise change it for a valid one via the "My Account" page.

This business rule is to be applied only if option customize_validation_message_from_context is set for the app (defaults to true in the member bundle). _&lt;= boolean yaml parameter set to true&gt;_


To illustrate such a new business rule : 
* in a cases like #66957 (tommasina.spampinato@virgilio.it) =&gt; it helps providing a quick fix once support has confirmed this email validity;
* and in cases like #68434 (farahnaouii@gmail:com) =&gt; it better guides the user on the proper page to fix such a mistake.

Furthermore, in order to monitor the occurence frequency of such a case, a message (with the invalid email value) is logged when such a case occurs (so only when the email is invalid AND ONLY if it is the email of an EXISTING member, as invalid member emails in registration scenarios are not in the targets scenarios to be taken into account, neither validation of email partners etc...).

@dev : see further technical design level requests in "Technical analysis / design" section.



----

h1. Dev notes

This section has been created with "this template":https://wiki.bilendi.net/doku.php/referentiel_de_pratiques:template_de_contenu#template_de_notes_de_dev

h2. Business analysis / solution

{{collapse()


}}

h2. Technical analysis / design

{{collapse()

STATUS : WIP

To complete the technical requirements written in the request, see the technical level requirements described in note #67084#note-30 / section "Conclusion / décision", for this solution :
* make a dedicated service to implement such a contextual message business rule,
...

The monitoring log action described in the request should not be implemented in such a service, whose purpose in to only implement the "message deduction business rule"; it should rather be implemented in the validator itself, so this leads to dividing the implementation of this new service in 4 new distinct actions/behaviors :
* if "email validation fails"
** _[new behavior]_  if customize_validation_message_from_context is true then :
*** _[new behavior]_ get the "failed validation context case" from context =&gt; this behavior resolves the "invalid case" from the validator context (namely the "object" of the context);
*** _[new behavior]_ add an "INFO log of the occurence of such case with the invalid email and the member id;
*** _[new behavior]_ get the violation message to be returned for this case;
** add the violation message in the context.

The "if customize_validation_message_from_context is true" is implemenyted by first checking if this email constraint is defiend in the incoming Email constraint object (= parameter of EmailValidator.validate() method);
if not then it checks the (new) customize_validation_message_from_context parameter of the EmailValidator service =&gt; this parameter is set to true in the member-bundles services.yml configuration of the EmailValidator service;
then one may define a class EmailValidatorContext  aside EmailValidator dedicated to resolving the validation case;
one may implement the "case" semantic  by an api of it like isExistingMemberCase() =&gt; so this class will just check that an "object" is in context and it is an object of "a member class" =&gt;  and return true only in this case;
as the current violation message implementation requires a refactoring for a long time, one may implement a dedicated class EmailValidatorMessage with an api setExistingMemberCaseMessage($constraintViolations) to implement this new case and another setDefaultCaseMessage($constraintViolations) to refactor the default case (set the default Sf invalid email message);
one also makes a getExistingMemberCaseLogMessage() returning a message consistant and unified with setExistingMemberCaseMessage, to be looged as an "INFO" log;
finally to ensure a loose coupling of the actual EmailValidator behavior and the customize_validation_message_from_context option, one can create a EmailValidatorContextRule service that implements the logic above when customize_validation_message_from_context is true, so that just the existing (refactored) execution of the EmailValidator is executed when this option is disabled (so = false).

added notes from dev iteration feedbacks :
* maybe prefer just add classes or trait, not necessarly a service yet : member bundle already has a lot of services making it heavy to initialize, so better not create a service as a class, if no real reuse use case concrete yet;
* add needed comments for refactoring of existing code;
* namely check if "addSource" is to be added to messages of Constraints Email, EmailBlacklist, EmailAccent and to class EmailValidatorMessage as described in comment of méthod : \Bilendi\MemberBundle\Validator\Constraints\EmailValidatorMessageManager::getTranslationMessages;
* manage optionally refactoring in another commit or leave it for a future ticket depending on delay/planning: the main point is to comment what is to be refactored (to not loose this knowledge).
* one also needs to check which of the following change email scenario alternatives customization forms are really used and cover them by a test if they are impacted by this change : &lt;pre&gt;
./pcp/src/AppBundle/Form/ChangeEmailType.php
./mpz/src/AppBundle/Form/Account/ChangeEmailType.php
./ivx/src/AppBundle/Form/Account/ChangeEmailType.php
./m3panel/src/AppBundle/Form/Account/ChangeEmailType.php
./baxi/src/AppBundle/Form/ChangeEmail/ChangeEmailType.php =&gt; discussion in wip about it on baxi chan =&gt; at date : no need to further test baxi as it excutes the same "member-bundle" scenario as mxm, if ever (from this discussion) an alternate change email scenario exists, then if this scenario si blocked because the email became invalid after email validation rules update, then the user can still fall back to the "member-bundle" scenario to fix his/her email.

&lt;/pre&gt;

}}

h2. Business test scenarios

{{collapse()

STATUS : WIP =&gt; see "Technical analysis / design" wection.

The scenarios below have to be performed at least on mxm and mpz to cover both non customized and customized email change scenario cases, combined to the "with and without date of birth check" alternatives : 
* mxm has no customization of the email change scenarios and executes with the "date of birth check" alternative,
* mpz has a customization of the email change scenarios  and executes with the "date of birth check" alternative,
* mxm with the 'change_email_request' configuration option removed, has no customization of the email change scenarios  and executes without the "date of birth check" alternative.


Non regression solution test scenarios with valid member email in db :
* the user has a valid email (f.delahaye+test7@bilendi.com);
* the update of a field from personal info form (lastname 'Galliot' changed for 'Galliott') works =&gt; OK or KO ?;
** same scenario from CCC =&gt; OK or KO ?
* test of validation of "gdpr acceptance"  form =&gt; OK or KO ?;
* test of validation of "unsubscribe"  form =&gt; OK or KO ?;
* test change email scenario, with date of birth check alternative, with a new invalid email =&gt; OK or KO ? ( new email f.delahaye+test8@bilendi:com);
* test change email scenario, with date of birth check alternative, with a new valid email =&gt; OK or KO ? ( new email f.delahaye+test8@bilendi.com);
* test change email scenario, without date of birth check alternative, with a new invalid email =&gt; OK or KO ? ( new email f.delahaye+test10@bilendi:com);
** same scenario from CCC =&gt; OK or KO ?
* test change email scenario, without date of birth check alternative, with a new valid email =&gt; OK or KO ? ( new email f.delahaye+test10@bilendi.com);
** same scenario from CCC =&gt; OK or KO ?


Correction solution test scenarios with an invalid member email in db, after new email validation rule deployed :
* a new email validation rule, that forbids email local part ending with "+test10" is deployed =&gt; then the email f.delahaye+test10@bilendi.com of the previous test case member has become invalid;
* the update of a field from personal info form (lastname 'Galliot' changed for 'Galliott') displays the expected invalid email message =&gt; OK or KO ?;
** same scenario from CCC =&gt; OK or KO ?
* test of validation of "gdpr accepatnce"  form displays the expected invalid email message =&gt; OK or KO ?;
* test of validation of "unsubscribe"  form displays the expected invalid email message =&gt; OK or KO ?;
* test change email scenario, with date of birth check alternative, with a new invalid email =&gt; displays the proper invalid email message =&gt; OK or KO ? ( new email f.delahaye+test8@bilendi:com);
* test change email scenario, with date of birth check alternative, with a new valid email =&gt; displays the proper invalid email message =&gt; OK or KO ? ( new email f.delahaye+test8@bilendi.com);
* test change email scenario, without date of birth check alternative, with a new invalid email =&gt; displays the proper invalid email message =&gt; OK or KO ? ( new email f.delahaye+test10@bilendi:com);
** same scenario from CCC =&gt; OK or KO ?
* test change email scenario, without date of birth check alternative, with a new valid email =&gt; displays the proper invalid email message =&gt; OK or KO ? ( new email f.delahaye+test10@bilendi.com);
** same scenario from CCC =&gt; OK or KO ?


}}

h2. Dev phase test report

{{collapse()


}}

h2. Validation phase test report

{{collapse()


}}

h2. Technical tests scenarios

{{collapse()


}}


h2. Technical test report

{{collapse()


}}


----</old_value>
      <new_value>{{ToC}}

h1. Requester request

_NB: technical level contents are annotated in italic notes delimited by &lt; and &gt;._
See note #67084#note-30 about such a case.
Goal of this tkt is to dev and deploy the solution described in section "Conclusion / décision" of this note.
In a word, here is the business rule to add to the email validator via this ticket :
* when the email is detected as invalid,
* if it is the email of an existing member, _&lt;= validated object retrieved from the validator context is (or inherits from) IdentityBase and its "actif" property is "O" or "J"&gt;_
* then the message sent back to the user/member is specifc to this context : it tells the user to the contact the customer support if he/she is sure his/her email is valid, otherwise change it for a valid one via the "My Account" page.

This business rule is to be applied only if option customize_validation_message_from_context is set for the app (defaults to true in the member bundle). _&lt;= boolean yaml parameter set to true&gt;_


To illustrate such a new business rule : 
* in a cases like #66957 (tommasina.spampinato@virgilio.it) =&gt; it helps providing a quick fix once support has confirmed this email validity;
* and in cases like #68434 (farahnaouii@gmail:com) =&gt; it better guides the user on the proper page to fix such a mistake.

Furthermore, in order to monitor the occurence frequency of such a case, a message (with the invalid email value) is logged when such a case occurs (so only when the email is invalid AND ONLY if it is the email of an EXISTING member, as invalid member emails in registration scenarios are not in the targets scenarios to be taken into account, neither validation of email partners etc...).

@dev : see further technical design level requests in "Technical analysis / design" section.



----

h1. Dev notes

This section has been created with "this template":https://wiki.bilendi.net/doku.php/referentiel_de_pratiques:template_de_contenu#template_de_notes_de_dev

h2. Business analysis / solution

{{collapse()


}}

h2. Technical analysis / design

{{collapse()

STATUS : WIP

To complete the technical requirements written in the request, see the technical level requirements described in note #67084#note-30 / section "Conclusion / décision", for this solution :
* make a dedicated service to implement such a contextual message business rule,
...

The monitoring log action described in the request should not be implemented in such a service, whose purpose in to only implement the "message deduction business rule"; it should rather be implemented in the validator itself, so this leads to dividing the implementation of this new service in 4 new distinct actions/behaviors :
* if "email validation fails"
** _[new behavior]_  if customize_validation_message_from_context is true then :
*** _[new behavior]_ get the "failed validation context case" from context =&gt; this behavior resolves the "invalid case" from the validator context (namely the "object" of the context);
*** _[new behavior]_ add an "INFO log of the occurence of such case with the invalid email and the member id;
*** _[new behavior]_ get the violation message to be returned for this case;
** add the violation message in the context.

The "if customize_validation_message_from_context is true" is implemenyted by first checking if this email constraint is defiend in the incoming Email constraint object (= parameter of EmailValidator.validate() method);
if not then it checks the (new) customize_validation_message_from_context parameter of the EmailValidator service =&gt; this parameter is set to true in the member-bundles services.yml configuration of the EmailValidator service;
then one may define a class EmailValidatorContext  aside EmailValidator dedicated to resolving the validation case;
one may implement the "case" semantic  by an api of it like isExistingMemberCase() =&gt; so this class will just check that an "object" is in context and it is an object of "a member class" =&gt;  and return true only in this case;
as the current violation message implementation requires a refactoring for a long time, one may implement a dedicated class EmailValidatorMessage with an api setExistingMemberCaseMessage($constraintViolations) to implement this new case and another setDefaultCaseMessage($constraintViolations) to refactor the default case (set the default Sf invalid email message);
one also makes a getExistingMemberCaseLogMessage() returning a message consistant and unified with setExistingMemberCaseMessage, to be looged as an "INFO" log;
finally to ensure a loose coupling of the actual EmailValidator behavior and the customize_validation_message_from_context option, one can create a EmailValidatorContextRule service that implements the logic above when customize_validation_message_from_context is true, so that just the existing (refactored) execution of the EmailValidator is executed when this option is disabled (so = false).

added notes from dev iteration feedbacks :
* maybe prefer just add classes or trait, not necessarly a service yet : member bundle already has a lot of services making it heavy to initialize, so better not create a service as a class, if no real reuse use case concrete yet;
* add needed comments for refactoring of existing code;
* namely check if "addSource" is to be added to messages of Constraints Email, EmailBlacklist, EmailAccent and to class EmailValidatorMessage as described in comment of méthod : \Bilendi\MemberBundle\Validator\Constraints\EmailValidatorMessageManager::getTranslationMessages;
* manage optionally refactoring in another commit or leave it for a future ticket depending on delay/planning: the main point is to comment what is to be refactored (to not loose this knowledge).
* one also needs to check which of the following change email scenario alternatives customization forms are really used and cover them by a test if they are impacted by this change : &lt;pre&gt;
./pcp/src/AppBundle/Form/ChangeEmailType.php
./mpz/src/AppBundle/Form/Account/ChangeEmailType.php
./ivx/src/AppBundle/Form/Account/ChangeEmailType.php
./m3panel/src/AppBundle/Form/Account/ChangeEmailType.php
./baxi/src/AppBundle/Form/ChangeEmail/ChangeEmailType.php =&gt; discussion in wip about it on baxi chan =&gt; at date : no need to further test baxi as it excutes the same "member-bundle" scenario as mxm, if ever (from this discussion) an alternate change email scenario exists, then if this scenario si blocked because the email became invalid after email validation rules update, then the user can still fall back to the "member-bundle" scenario to fix his/her email.

&lt;/pre&gt;

}}

h2. Business test scenarios

{{collapse()

STATUS : WIP =&gt; see "Technical analysis / design" wection.

The scenarios below have to be performed at least on mxm and mpz to cover both non customized and customized email change scenario cases, combined to the "with and without date of birth check" alternatives : 
* mxm has no customization of the email change scenarios and executes with the "date of birth check" alternative,
* mpz has a customization of the email change scenarios  and executes with the "date of birth check" alternative,
* mxm with the 'change_email_request' configuration option removed, has no customization of the email change scenarios  and executes without the "date of birth check" alternative.


Non regression solution test scenarios with valid member email in db :
* case 1: the user has a valid email (f.delahaye+test7@bilendi.com);
* scenario 1: the update of a field from personal info form (lastname 'Galliot' changed for 'Galliott') works =&gt; OK or KO ?;
** scenario 1.1: same scenario from CCC =&gt; OK or KO ?
* scenario 2: test of validation of "gdpr acceptance"  form =&gt; OK or KO ?;
* scenario 3: test of validation of "unsubscribe"  form =&gt; OK or KO ?;
* scenario 4: test change email scenario, with date of birth check alternative, with a new invalid email =&gt; OK or KO ? ( new email abuse@bilendi.com);
* scenario 5: test change email scenario, with date of birth check alternative, with a new valid email =&gt; OK or KO ? ( new email f.delahaye+test8@bilendi.com);
* scenario 6: test change email scenario, without date of birth check alternative, with a new invalid email =&gt; OK or KO ? ( new email abuse@bilendi.com);
** scenario 6.1: same scenario from CCC =&gt; OK or KO ?
* scenario 7: test change email scenario, without date of birth check alternative, with a new valid email =&gt; OK or KO ? ( new email f.delahaye+test10@bilendi.com);
** scenario 7.1: same scenario from CCC =&gt; OK or KO ?


Correction solution test scenarios with an invalid member email in db, after new email validation rule deployed :
* case 2: a new email validation rule, that forbids email local part ending with "+test10" is deployed =&gt; then the email f.delahaye+test10@bilendi.com of the previous test case member has become invalid;
* scenario 8: the update of a field from personal info form (lastname 'Galliot' changed for 'Galliott') displays the expected invalid email message =&gt; OK or KO ?;
** scenario 8.1: same scenario from CCC =&gt; OK or KO ?
* scenario 9: test of validation of "gdpr acceptance"  form displays the expected invalid email message =&gt; OK or KO ?;
* scenario 10: test of validation of "unsubscribe"  form displays the expected invalid email message =&gt; OK or KO ?;
* scenario 11: test change email scenario, with date of birth check alternative, with a new invalid email =&gt; displays the proper invalid email message =&gt; OK or KO ? ( new email abuse@bilendi.com);
* scenario 12: test change email scenario, with date of birth check alternative, with a new valid email =&gt; OK or KO ? ( new email f.delahaye+test8@bilendi.com);
* scenario 13: test change email scenario, without date of birth check alternative, with a new invalid email =&gt; displays the proper invalid email message =&gt; OK or KO ? ( new email abuse@bilendi.com);
** scenario 13.1: same scenario from CCC =&gt; OK or KO ?
* scenario 14: test change email scenario, without date of birth check alternative, with a new valid email =&gt; OK or KO ? ( new email f.delahaye+test7@bilendi.com);
** scenario 14.1: same scenario from CCC =&gt; OK or KO ?


}}

h2. Dev phase test report

{{collapse()

STATUS : WIP

h3. Dev phase test report on mxm app

_See screenshots of this tests in note #68616#note-16, #68616#note-17._

Non regression solution test scenarios with valid member email in db :
* case 1: the user has a valid email (f.delahaye+test7@bilendi.com);
* scenario 1: the update of a field from personal info form (lastname 'Galliot' changed for 'Galliott') works =&gt; OK;
** scenario 1.1: same scenario from CCC =&gt; OK or KO ?
* scenario 2: test of validation of "gdpr acceptance"  form =&gt; OK;
* scenario 3: test of validation of "unsubscribe"  form =&gt; OK;
* scenario 4: test change email scenario, with date of birth check alternative, with a new invalid email =&gt; OK ( new email abuse@bilendi.com);
* scenario 5: test change email scenario, with date of birth check alternative, with a new valid email =&gt; OK ( new email f.delahaye+test8@bilendi.com);
* scenario 6: test change email scenario, without date of birth check alternative, with a new invalid email =&gt; OK ( new email abuse@bilendi.com);
** scenario 6.1: same scenario from CCC =&gt; OK or KO ?
* scenario 7: test change email scenario, without date of birth check alternative, with a new valid email =&gt; OK ( new email f.delahaye+test10@bilendi.com);
** scenario 7.1: same scenario from CCC =&gt; OK or KO ?


Correction solution test scenarios with an invalid member email in db, after new email validation rule deployed :
* case 2: a new email validation rule, that forbids email local part ending with "+test10" is deployed =&gt; then the email f.delahaye+test10@bilendi.com of the previous test case member has become invalid;
* scenario 8: the update of a field from personal info form (lastname 'Galliot' changed for 'Galliott') displays the expected invalid email message =&gt; OK;
** scenario 8.1: same scenario from CCC =&gt; OK or KO ?
* scenario 9: test of validation of "gdpr acceptance"  form displays the expected invalid email message =&gt; OK;
* scenario 10: test of validation of "unsubscribe"  form displays the expected invalid email message =&gt; OK;
* scenario 11: test change email scenario, with date of birth check alternative, with a new invalid email =&gt; displays the proper invalid email message =&gt; OK ( new email abuse@bilendi.com);
* scenario 12: test change email scenario, with date of birth check alternative, with a new valid email =&gt; OK ( new email f.delahaye+test8@bilendi.com);
* scenario 13: test change email scenario, without date of birth check alternative, with a new invalid email =&gt; displays the proper invalid email message =&gt; OK ( new email abuse@bilendi.com);
** scenario 13.1: same scenario from CCC =&gt; OK or KO ?
* scenario 14: test change email scenario, without date of birth check alternative, with a new valid email =&gt; OK or KO ? ( new email f.delahaye+test7@bilendi.com);
** scenario 14.1: same scenario from CCC =&gt; OK or KO ?

}}

h2. Validation phase test report

{{collapse()


}}

h2. Technical tests scenarios

{{collapse()


}}


h2. Technical test report

{{collapse()


}}


----</new_value>
    </detail>
    <detail property="attachment" name="98932">
      <old_value/>
      <new_value>scenario_1.png</new_value>
    </detail>
    <detail property="attachment" name="98935">
      <old_value/>
      <new_value>scenario_3.png</new_value>
    </detail>
    <detail property="attachment" name="98933">
      <old_value/>
      <new_value>scenario_4.png</new_value>
    </detail>
    <detail property="attachment" name="98934">
      <old_value/>
      <new_value>scenario_5.png</new_value>
    </detail>
    <detail property="attachment" name="98936">
      <old_value/>
      <new_value>scenario_6.png</new_value>
    </detail>
    <detail property="attachment" name="98937">
      <old_value/>
      <new_value>scenario_7.png</new_value>
    </detail>
    <detail property="attachment" name="98938">
      <old_value/>
      <new_value>scenario_8.png</new_value>
    </detail>
    <detail property="attachment" name="98940">
      <old_value/>
      <new_value>scenario_9.png</new_value>
    </detail>
    <detail property="attachment" name="98939">
      <old_value/>
      <new_value>scenario_10.png</new_value>
    </detail>
    <detail property="attachment" name="98941">
      <old_value/>
      <new_value>scenario_11.png</new_value>
    </detail>
  </details>
</journal>
<journal id="639114">
  <user id="529" name="Franck D."/>
  <notes>Adds wip of dev phase test report on mxm app (mxm CCC test report to be added).</notes>
  <created_on>2021-06-11T09:03:04Z</created_on>
  <private_notes>false</private_notes>
  <details type="array">
    <detail property="attachment" name="98943">
      <old_value/>
      <new_value>scenario_14.png</new_value>
    </detail>
    <detail property="attachment" name="98944">
      <old_value/>
      <new_value>scenario_12.png</new_value>
    </detail>
    <detail property="attachment" name="98945">
      <old_value/>
      <new_value>scenario13.png</new_value>
    </detail>
  </details>
</journal>
<journal id="639252">
  <user id="529" name="Franck D."/>
  <notes>Attached screenshots are two new email change request customization scenarios (baxi and atout-france), that are to be checked for potential impacts of this change</notes>
  <created_on>2021-06-14T06:34:49Z</created_on>
  <private_notes>false</private_notes>
  <details type="array">
    <detail property="attachment" name="98966">
      <old_value/>
      <new_value>Capture d’écran 2021-06-14 à 08.23.36.png</new_value>
    </detail>
    <detail property="attachment" name="98967">
      <old_value/>
      <new_value>Capture d’écran 2021-06-14 à 08.26.04.png</new_value>
    </detail>
  </details>
</journal>
<journal id="639323">
  <user id="529" name="Franck D."/>
  <notes>Ticket reject status :
* here are the reasons leading to the decision to reject this ticket :
* initial goal of this ticket are :
** from a business point of view : to provide a common solution to the case of an email that has become invalid, because of a change in a new version of the email validation constraints deployed in production;
** from a technical point of view : to limit as much as possible in the solution : its complexity and "apps specific" changes;
* namely, this request was created from a previous one avoiding "good members" to be blocked by the email validation because of a "too strong 'spam' constraints pushed in production regarding their own specific email" : &lt;pre&gt;
tommasina.spampinato@virgilio.it
mariaelisa.spampinato89@gmail.com
spampima@gmail.com
&lt;/pre&gt;
* so the idea is to provide a common solution guiding members in such cases, whatever the reason is because of a "two strong 'spam' constraint" or another constraint;
* yet, from 5 years back experience, such a case has only occured because of a two strong 'spam' constraint for specific member emails, and never because of the others email constraints =&gt; so making a solution applying to ANY email constraints is not that much a real requirement from this experience feedback;
* furthermore, the technical analysis made in the previous notes and in the "Dev notes" section of tkt Description, identifies a bunch of potential impacts to be checked, namely on customized email change request scenario, in differnt apps =&gt; leading to the identification of duplicated customized code, that should at least be factorized in a bundle to avoid, again duplicating the new code added + multiple branch managment + multiple test scenarios etc...;
* furthermore, a lead/admin talk, lead to consider that the managment of such case only because of the 'spam' constraint, is much less possible after the last fix refusing only email local parts "ending by 'spam'", instead  of "containing  'spam'";
* furthermore, if this 'spam' constraint 'looseness' would sometime authorize "bad 'spam' emails", then a simple alternative would be to disable it again, and manage a whitelist with the authorized 'spam' emails like the ones above =&gt; the 5 years back experience confirms that there a not so much such cases, and that a (hashtable based) php array is okay to implement such a basic whitelist;
* so considering that this change :
** is not really mandatory today to solve a real issue;
** and adds :
*** heavy impacts analysis process, 
*** heavy customized duplicated code test coverage of code that should be first factorized,
*** and also some more dependencies of the email validator feature with other services (like session service), which increase its complexity,
* descision is to reject this ticket for now,
* plan the needed customized code refactoring tasks,
* and reconsider it once they are done, and if ever a case not managed by the "whitelist" solution described above would justify it.

_NB : issues #67996 and #67443 have also been discussed with colleagues, and could have pushed to make such a "common solution" to manage existing members in such cases, that is with email having slashes and/or ending with 'spam', but this two request cases asking for a common solution (implictely for any apps), have been rejected after analysis (and/or repurposed with an alternate solution for now)._</notes>
  <created_on>2021-06-14T10:24:09Z</created_on>
  <private_notes>false</private_notes>
  <details type="array">
    <detail property="attr" name="status_id">
      <old_value>2</old_value>
      <new_value>6</new_value>
    </detail>
  </details>
</journal>
<journal id="639446">
  <user id="529" name="Franck D."/>
  <notes>branch and merge request of this tkt are pushed as Draft, to keep the code made and dev tested before the reject decision, in case of catch up of such an issue.</notes>
  <created_on>2021-06-15T06:32:35Z</created_on>
  <private_notes>false</private_notes>
  <details type="array">
    <detail property="cf" name="16">
      <old_value/>
      <new_value>DON'T MERGE ME ! see #68616#note-20
https://gitlab.bilendi.net/dev/bilendi-member-bundle/-/merge_requests/370</new_value>
    </detail>
  </details>
</journal></issue_68616>
<issue_68610>
<issue_url>https://redmine.bilendi.com/issues/68610</issue_url>
</issue_68610>
<issue_68608>
<issue_url>https://redmine.bilendi.com/issues/68608</issue_url>
</issue_68608>
<issue_68607>
<issue_url>https://redmine.bilendi.com/issues/68607</issue_url>
</issue_68607>
<issue_68605>
<issue_url>https://redmine.bilendi.com/issues/68605</issue_url>
</issue_68605>
<issue_68603>
<issue_url>https://redmine.bilendi.com/issues/68603</issue_url>
</issue_68603>
<issue_68602>
<issue_url>https://redmine.bilendi.com/issues/68602</issue_url>
</issue_68602>
<issue_68601>
<issue_url>https://redmine.bilendi.com/issues/68601</issue_url>
</issue_68601>
<issue_68600>
<issue_url>https://redmine.bilendi.com/issues/68600</issue_url>
</issue_68600>
<issue_68598>
<issue_url>https://redmine.bilendi.com/issues/68598</issue_url>
</issue_68598>
<issue_68596>
<issue_url>https://redmine.bilendi.com/issues/68596</issue_url>
</issue_68596>
<issue_68595>
<issue_url>https://redmine.bilendi.com/issues/68595</issue_url>
</issue_68595>
<issue_68593>
<issue_url>https://redmine.bilendi.com/issues/68593</issue_url>
</issue_68593>
<issue_68592>
<issue_url>https://redmine.bilendi.com/issues/68592</issue_url>
</issue_68592>
<issue_68590>
<issue_url>https://redmine.bilendi.com/issues/68590</issue_url>
</issue_68590>
<issue_68589>
<issue_url>https://redmine.bilendi.com/issues/68589</issue_url>
</issue_68589>
<issue_68588>
<issue_url>https://redmine.bilendi.com/issues/68588</issue_url>
</issue_68588>
<issue_68586>
<issue_url>https://redmine.bilendi.com/issues/68586</issue_url>
</issue_68586>
<issue_68585>
<issue_url>https://redmine.bilendi.com/issues/68585</issue_url>
</issue_68585>
<issue_68579>
<issue_url>https://redmine.bilendi.com/issues/68579</issue_url>
</issue_68579>
<issue_68577>
<issue_url>https://redmine.bilendi.com/issues/68577</issue_url>
</issue_68577>
<issue_68576>
<issue_url>https://redmine.bilendi.com/issues/68576</issue_url>
</issue_68576>
<issue_68575>
<issue_url>https://redmine.bilendi.com/issues/68575</issue_url>
</issue_68575>
<issue_68574>
<issue_url>https://redmine.bilendi.com/issues/68574</issue_url>
</issue_68574>
<issue_68572>
<issue_url>https://redmine.bilendi.com/issues/68572</issue_url>
</issue_68572>
<issue_68571>
<issue_url>https://redmine.bilendi.com/issues/68571</issue_url>
<journal id="639637">
  <user id="529" name="Franck D."/>
  <notes>MET DONE NOW : {{collapse(sql script execution log)

&lt;pre&gt;
[2021-06-15 16:56:50] Connected
dbddi_testing.public&gt; BEGIN
[2021-06-15 16:56:50] completed in 47 ms
dbddi_testing.public&gt; UPDATE department
                      SET id_regional_directorate = (SELECT id_regional_directorate FROM regional_directorates WHERE name = 'SUD OUEST')
                      WHERE department_number = '12'
[2021-06-15 16:57:00] 1 row affected in 71 ms
dbddi_testing.public&gt; UPDATE department
                      SET id_regional_directorate = (SELECT id_regional_directorate FROM regional_directorates WHERE name = 'AUVERGNE RHONE ALPES')
                      WHERE department_number = '15'
[2021-06-15 16:57:05] 1 row affected in 48 ms
dbddi_testing.public&gt; COMMIT
[2021-06-15 16:57:25] completed in 49 ms
&lt;/pre&gt;

}}

card is moved in testing trello column with dev tagged for dev test in testing.</notes>
  <created_on>2021-06-15T15:02:07Z</created_on>
  <private_notes>false</private_notes>
  <details type="array"/>
</journal>
<journal id="639639">
  <user id="529" name="Franck D."/>
  <notes/>
  <created_on>2021-06-15T15:04:58Z</created_on>
  <private_notes>false</private_notes>
  <details type="array">
    <detail property="attr" name="status_id">
      <old_value>20</old_value>
      <new_value>8</new_value>
    </detail>
  </details>
</journal>
<journal id="640086">
  <user id="529" name="Franck D."/>
  <notes>la vérif du nom de la bdd en prod donne : dbddi (sur lr serveur db-ddi.prod.bilendi.net);
l'exécution du script de MET en note #68571#note-5 indique comme nom de bdd : dbddi_testing;
on en déduit que ce script a été exécuté sur la bdd de testing et pas de prod;
par ailleurs les seul agent trouvés en bdd de testing qui travaillent pour le département 15 (= sont liés à ce dpt en bdd), sont :
* gilles.desplaces@dedietrichthermique.com;
* patrick.touraille@dedietrichthermique.com;

cf les screenshots de ces deux agent :
* ils ont tous les deux le dpt 15, mais chacun a un directeur (ou direction) régional différent;
* en effet la logique de base de de ddi concernant la structuration agent/direction régionale/departement est :
** un agent est rattaché directement à une et une seule direction régionale (on va dire la direction dont il dépend administrativement ou logique dans ce genre...);
** mais il peut exercer sont activité pour le compte de plusieurs département, eux mêmes rattachés à des direction régionales potentiellement différentes;

(le schema en attaché avec les flêches jaune illustre cette structuration)

Donc le tableau des screenshots se lit ainsi :
- colonne "Départements" = tous les dpt pour lequel l'agent exerce une activité;
- colonne "Directeur Régionale" = la direction régionale de rattachement de l'agent =&gt; qui peut donc n'être aucune des directions régionales des dpt de la colonne "Départements", ou l'une d'entre elles, bref ces deux colonnes ne permettent pas au final, de vérifier les liens "Départements" / "Direction Régionale".

... et de souvenir je suis pas sûr qu'il y ait un écran permettant de vérifier ces liens... à défaut, voilà ce que me dit la bdd de testing concernant les directions régionales des dpt 12 et 15 :
&lt;pre&gt;
select department_number , name as direction_regionale
from department
join regional_directorates rd on department.id_regional_directorate = rd.id_regional_directorate

where department_number in ('12','15');


--résultat :

12,SUD OUEST
15,AUVERGNE RHONE ALPES

&lt;/pre&gt;

... et en prod :
&lt;pre&gt;
select department_number , name as direction_regionale
from department
join regional_directorates rd on department.id_regional_directorate = rd.id_regional_directorate

where department_number in ('12','15');


--résultat :

15,MEDITERRANEE
12,MEDITERRANEE


&lt;/pre&gt;

A défaut de pouvoir faire d'autres vérif plus niveau métier, voilà déjà ma conte-vérif via ces rqt en bdd;
je repasse le tkt en testing pour d'éventuelle validation complémentaires et/ou décider de valider sur cette base là...</notes>
  <created_on>2021-06-17T12:31:29Z</created_on>
  <private_notes>false</private_notes>
  <details type="array">
    <detail property="attr" name="status_id">
      <old_value>2</old_value>
      <new_value>8</new_value>
    </detail>
    <detail property="attachment" name="99047">
      <old_value/>
      <new_value>Capture d’écran 2021-06-17 à 13.52.29.png</new_value>
    </detail>
    <detail property="attachment" name="99048">
      <old_value/>
      <new_value>Capture d’écran 2021-06-17 à 14.01.47.png</new_value>
    </detail>
    <detail property="attr" name="assigned_to_id">
      <old_value>355</old_value>
      <new_value>883</new_value>
    </detail>
    <detail property="attachment" name="99046">
      <old_value/>
      <new_value>Capture d’écran 2021-06-17 à 13.52.08.png</new_value>
    </detail>
  </details>
</journal>
<journal id="640388">
  <user id="529" name="Franck D."/>
  <notes>{{collapse(MEP and result check done)
&lt;pre&gt;
dbddi.public&gt; select department_number , name as direction_regionale
              from department
                       join regional_directorates rd on department.id_regional_directorate = rd.id_regional_directorate
              
              where department_number in ('12','15')

-- Result :

15,MEDITERRANEE
12,MEDITERRANEE
----------------


[2021-06-21 08:01:17] 2 rows retrieved starting from 1 in 129 ms (execution: 45 ms, fetching: 84 ms)
dbddi.public&gt; BEGIN
[2021-06-21 08:01:39] completed in 49 ms
dbddi.public&gt; UPDATE department
              SET id_regional_directorate = (SELECT id_regional_directorate FROM regional_directorates WHERE name = 'SUD OUEST')
              WHERE department_number = '12'
[2021-06-21 08:01:39] 1 row affected in 45 ms
dbddi.public&gt; UPDATE department
              SET id_regional_directorate = (SELECT id_regional_directorate FROM regional_directorates WHERE name = 'AUVERGNE RHONE ALPES')
              WHERE department_number = '15'
[2021-06-21 08:01:40] 1 row affected in 43 ms
dbddi.public&gt; COMMIT
[2021-06-21 08:02:01] completed in 51 ms
dbddi.public&gt; select department_number , name as direction_regionale
              from department
                       join regional_directorates rd on department.id_regional_directorate = rd.id_regional_directorate
              
              where department_number in ('12','15')
[2021-06-21 08:02:16] 2 rows retrieved starting from 1 in 176 ms (execution: 46 ms, fetching: 130 ms)

-- Result :
12,SUD OUEST
15,AUVERGNE RHONE ALPES
------------
&lt;/pre&gt;
}}

I leave the tkt on Mabel for the check in prod =&gt; to be moved then on "Team CT" after the check (and on "To do" if ever the check is ko...).</notes>
  <created_on>2021-06-21T06:10:30Z</created_on>
  <private_notes>false</private_notes>
  <details type="array">
    <detail property="attr" name="status_id">
      <old_value>9</old_value>
      <new_value>5</new_value>
    </detail>
    <detail property="attr" name="assigned_to_id">
      <old_value>355</old_value>
      <new_value>883</new_value>
    </detail>
  </details>
</journal>
<journal id="640395">
  <user id="529" name="Franck D."/>
  <notes>ha oui c'est "available in prod" dsl... je confond avec le statut DONE qui veut dire pareil mais sur la board bundle (à moins qu'il soit obsolete...)</notes>
  <created_on>2021-06-21T06:53:30Z</created_on>
  <private_notes>true</private_notes>
  <details type="array"/>
</journal></issue_68571>
<issue_68568>
<issue_url>https://redmine.bilendi.com/issues/68568</issue_url>
</issue_68568>
<issue_68565>
<issue_url>https://redmine.bilendi.com/issues/68565</issue_url>
</issue_68565>
<issue_68563>
<issue_url>https://redmine.bilendi.com/issues/68563</issue_url>
</issue_68563>
<issue_68556>
<issue_url>https://redmine.bilendi.com/issues/68556</issue_url>
</issue_68556>
<issue_68555>
<issue_url>https://redmine.bilendi.com/issues/68555</issue_url>
</issue_68555>
<issue_68554>
<issue_url>https://redmine.bilendi.com/issues/68554</issue_url>
</issue_68554>
<issue_68552>
<issue_url>https://redmine.bilendi.com/issues/68552</issue_url>
</issue_68552>
<issue_68538>
<issue_url>https://redmine.bilendi.com/issues/68538</issue_url>
</issue_68538>
</journals>
